function [samples,nIterations] = removeiters(samples,badIters)
%REMOVEITERS removes iterations that you dislike.
% 
% [SAMPLES] = REMOVEITERS(SAMPLES,BADITERS)
%   this function removes (or "burns") iterations from a structure of
%   posterior samples, SAMPLES (in the format generated by
%   extractsamples.m).  
%   this may be useful to apply a post hoc burn-in, to thin samples, etc.
%   if BADITERS is scalar, then the first BADITERS iterations are burned.
%   if BADITERS is a vector, then the iteration indices in BADITERS will
%   be removed.  
%   the same iterations are removed for every chain, for parameter in the
%   SAMPLES structure.  SAMPLES is then returned. 
% 
% [SAMPLES,NITERATIONS] = REMOVEITERS(...)
%   while this function may be called with only one output argument, 
%   it is highly suggested to call the function with both output 
%   arguments, such that nIterations is reassigned in the workspace to 
%   reflect the new, fewer number of iterations.
% 
% NOTE: THIS FUNCTION IS NOT A SOLUTION FOR DIVERGENT TRANSITIONS.
% NOTE: be wary of inadvertently applying this function more than once!
% 
% 
% See also REMOVECHAIN, EXTRACTSAMPLES
% 
% (c) beth baribault 2019 ---                                 > matstanlib 

%% check inputs
%samples
if ~isstruct(samples)
    error('the first input must be the samples structure.')
end
%badIters
if ~isnumeric(badIters) || ~isvector(badIters)
    error('badIters input must be a numeric vector.')
elseif any(mod(badIters,1) > 0) || any(badIters < 1)
    error('badIters must be an integer or vector of integers > 0.')
end

%% check if request is in a valid format
%extract the number of iterations
parameters = fieldnames(samples);
nIterations = size(samples.(parameters{1}),1);

%which iters to burn?
if isscalar(badIters)
    %burn first N iterations
    nBadIters = badIters;
    badIters = 1:nBadIters; %(nBadIters+1):nIterations;
else
    %remove the given indices
    badIters = unique(badIters);
    nBadIters = numel(badIters);
end

%check if request is valid, given the number of iterations
if any(~ismember(badIters,1:nIterations))
    error(['the badIters input is invalid.  at least one index is ' ...
        'out of range given that there are %i iterations.'],nChains)
end
if nBadIters >= nIterations
    error(['cannot burn %i of %i iterations --- ' ...
        'no iterations would be left!'],nBadIters,nIterations)
end

%% burn the requested iterations
keptIters = setdiff(1:nIterations,badIters);
for p = 1:length(parameters)
    clearvars ind
    ind(1:ndims(samples.(parameters{p}))) = {':'};
    ind{1} = keptIters;
    samples.(parameters{p}) = samples.(parameters{p})(ind{:});
end

%reassign nIterations to reflect removal of iterations
nIterations = numel(keptIters); 

%output warnings
if nargout < 2
    warning(['if there is a nIterations variable in the workspace, ' ...
        'its value is now incorrect!  please reassign it such that ' ...
        'nIterations = %i.'],nIterations)
end

end