function [varargout] = overlaydensity(samples,parameterRequest,varargin)
%OVERLAYDENSITY generates a plot of smoothed densities for mutiple parameters.
% 
% this function generates a single figure in which smoothed densities for
% each parameter instance are overlaid.  on each density, the transparent
% shading is overlaid by a vertical line at the posterior sample mean, and
% an outline of the 95% central credible interval. 
% 
% optionally, a quantile summary bar for each parameter may be included
% beneath the densities.  on the summary bar, the thin line represents the
% central 95% credible interval, the thick line represents the central 50%
% credible interval, and the marker represents the median. 
% 
% OVERLAYDENSITY(SAMPLES,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of posterior samples in the format 
%   generated by extractsamples.m.  
%   PARAMETERREQUEST is parameter name string or cell of strings.
%   specific parameter instances (e.g., 'theta[4]') may be included. 
%   for each parameter instance, a smoothed density is added to the plot. 
% 
% 
% optional inputs may be given as property name-value pairs:
% OVERLAYDENSITY(...,'name1',VALUE1,'name1',VALUE2,...)
% pairs may be given in any order.  property names are case insensitive.
%   
%   'shading'
%       SHADING curtails the shading inside the violin to the bounds of 
%       the 100*SHADING% credible interval. as such, SHADING must be 
%       between 0 and 1. if SHADING is 0, then no shading is applied.
%       the default value for SHADING is 0.99.
%   
%   'outline'
%       OUTLINE curtails the outline of the violin to the bounds of the
%       100*OUTLINE% credible interval. as such, OUTLINE must be between 
%       0 and 1.  if OUTLINE is 0,then no outline is applied. 
%       the default value for OUTLINE is 0.95. 
%   
%   'criticalvalue'
%       CRITICALVALUE must be a scalar, numerical value.  
%       supplying CRITICALVALUE triggers the underlay of a vertical line
%       at the given value. 
%   
%   'addestimate'
%       ADDESTIMATE may be true or false.
%       if true, a dotted vertical line spanning the height of the density
%       will be added at the the posterior sample mean.
%       the default value for ADDESTIMATE is true.
%   
%   'addinterval'
%       ADDINTERVAL may be true or false.
%       if true, the 95% CI (as a thin line), 50% CI (as a thick line), and
%       the median (as a circular marker), will be added to the plot. this
%       interval plot is aligned to the bottom of each density.  
%       the default value for ADDINTERVAL is false.
%   
%   'fillcolor'
%       optionally, override the default fill color scheme (rainbow) by
%       including FILLCOLOR as the third input. FILLCOLOR must be a 1x3 or
%       Nx3 matrix (where N is the number of parameter instances). 
%       if FILLCOLOR is 1x3, then the same color is used for all parameter
%       instances. if FILLCOLOR is Nx3 then each row is used for each
%       successive parameter instance.
%   
%   'fillalpha'
%       override the default fill opacity (0.35) with a custom opacity
%       value, FILLALPHA.  FILLALPHA must be between 0 and 1.
%   
%   'outlinecolor'
%       optionally, override the default outline color scheme (all black)
%       with the color(s) given in MARKERCOLOR.  
%       the size and usage demands are the same as for FILLCOLOR.
%   
%   'method'
%       METHOD indicates how the violin should be scaled.  
%       if METHOD is 'height', then all violins are scaled to be the equal
%       in height (i.e., the same width on the plot).
%       if METHOD is 'area', then each violins is scaled such that they are
%       equal in area (i.e., so that each violin's width is proportional to
%       its highest density *relative to* the highest density across *all*
%       violins on the plot). 
%       the default value for METHOD is 'area'.
% 
% 
% See also HORZDENSITY, VIOLINDENSITY, PLOTINTERVALS, PLOTDENSITY, 
%   JOINTDENSITY, MULTIDENSITY, SMOOTHDENSITY, EXTRACTSAMPLES
% 
% (c) beth baribault 2021 ---                                 > matstanlib 

matstanlib_options

%% parse required inputs
if nargin < 2
    error('too few inputs.')
end

%samples
if ~isstruct(samples)
    error('the first input must be a structure of mcmc samples.')
end

%parameterRequest
if isempty(parameterRequest)
    parameterRequest = fieldnames(samples);
elseif ~(iscell(parameterRequest) && all(cellfun(@ischar,parameterRequest)))
    if ischar(parameterRequest)
        parameterRequest = {parameterRequest};
    else
        error(['parameterRequest must be a string or cell of strings ' ...
               'containing valid parameter or instance name strings.'])
    end
end

%% parse optional inputs
%ensure all remaining inputs are consistent with name-value pair format
if mod(length(varargin),2) > 0 || ...
        ~all(cellfun(@ischar,varargin(1:2:length(varargin))))
    error(['all inputs (after samples and parameterRequest) ' ...
        'must be submitted as name-value pairs.'])
elseif length(unique(varargin(1:2:length(varargin))))<length(varargin(1:2:length(varargin)))
    error('at least one property name (in the name-value pair inputs) is a duplicate.')
end

%set default values for the optional inputs
shading = 0.99;
outline = 0.95;
criticalValue = NaN;
addEstimate = true;
addInterval = false;
fillColor = NaN;    %use default colors
fillAlpha = 0.35;
outlineColor = NaN; %use default colors
markerColor = NaN;  %use default colors

varargin(1:2:length(varargin)) = ... %case insensitive (convert all to lower case)
    cellfun(@lower,varargin(1:2:length(varargin)),'uni',0);
for v = 1:2:length(varargin)
    switch varargin{v}
        %----------------------------------------------------------------%
        case 'shading'
            shading = varargin{v+1};
            if ~isnumeric(shading) || ~isscalar(shading)
                error('shading must be a single numeric value.')
            elseif shading < 0 || shading > 1
                error('shading must be a proportion between 0 and 1.')
            end
        %----------------------------------------------------------------%
        case 'outline'
            outline = varargin{v+1};
            if ~isnumeric(outline) || ~isscalar(outline)
                error('outline must be a single numeric value.')
            elseif outline < 0 || outline > 1
                error('outline must be a proportion between 0 and 1.')
            end
        %----------------------------------------------------------------%
        case 'criticalvalue'
            criticalValue = varargin{v+1};
            if ~isnumeric(criticalValue) || ~isscalar(criticalValue)
                error('criticalvalue must be a single number.')
            end
        %----------------------------------------------------------------%
        case 'addestimate'
            addEstimate = varargin{v+1};
            if ~isscalar(addEstimate) && ~ismember(addEstimate,[0 1])
                error('addEstimate must be a true/1 or false/0 value.')
            end
        %----------------------------------------------------------------%
        case 'addinterval'
            addInterval = varargin{v+1};
            if ~isscalar(addInterval) && ~ismember(addInterval,[0 1])
                error('addInterval must be a true/1 or false/0 value.')
            end
        %----------------------------------------------------------------%
        case 'fillcolor'
            fillColor = varargin{v+1};
            if isscalar(fillColor) && (isnan(fillColor) || isempty(fillColor))
                %do nothing --- will use default colors
            elseif ~ismatrix(fillColor) || size(fillColor,2)~=3 
                error(['fillcolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(fillColor)))
            elseif isnumeric(fillColor)
                if ~ismatrix(fillColor) || size(fillColor,2)~=3 
                    error(['fillcolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(fillColor)))
                elseif ~all(fillColor(:)<=1) || ~all(fillColor(:)>=0) 
                    error(['each row of fillcolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('fillcolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'fillalpha'
            fillAlpha = varargin{v+1};
            if ~isnumeric(fillAlpha)
                error('fillAlpha must be a numeric value.')
            elseif isempty(fillAlpha)
                %use default
            elseif ~isvector(fillAlpha)
                error('fillAlpha must be scalar or vector.')
            elseif any(fillAlpha(:) < 0 | fillAlpha(:) > 1)
                error('fillAlpha must be between 0 and 1.')
            end
        %----------------------------------------------------------------%
        case 'outlinecolor'
            outlineColor = varargin{v+1};
            if isscalar(outlineColor) && (isnan(outlineColor) || isempty(outlineColor))
                %do nothing --- will use default color
            elseif ~ismatrix(outlineColor) || size(outlineColor,2)~=3 
                error(['outlinecolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(outlineColor)))
            elseif isnumeric(outlineColor)
                if ~ismatrix(outlineColor) || size(outlineColor,2)~=3 
                    error(['outlinecolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(outlineColor)))
                elseif ~all(outlineColor(:)<=1) || ~all(outlineColor(:)>=0) 
                    error(['each row of outlinecolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('outlinecolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'markercolor'
            markerColor = varargin{v+1};
            if isscalar(markerColor) && (isnan(markerColor) || isempty(markerColor))
                %do nothing --- will use default color
            elseif ~ismatrix(markerColor) || size(markerColor,2)~=3 
                error(['markercolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(markerColor)))
            elseif isnumeric(markerColor)
                if ~ismatrix(markerColor) || size(markerColor,2)~=3 
                    error(['markercolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(markerColor)))
                elseif ~all(markerColor(:)<=1) || ~all(markerColor(:)>=0) 
                    error(['each row of markercolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('markercolor must be numeric.')
            end
        %----------------------------------------------------------------%
        otherwise
            error('the optional input name ''%s'' was not recognized.', ...
                varargin{v})
    end
end

%% create a list of parameter instances
parameters = getparaminstances(parameterRequest, ...
    fieldnames(samples),struct2cell(structfun(@size,samples,'uni',0)));
isInstance = cellfun(@(x) any(x=='['),parameters);
nParameters = length(parameters);

%% get some nice colors for plotting

defaultFillColors = getcolors('ocean');
defaultFillColor = getcolors('paleblue'); %if too many
defaultFillAlpha = 0.35;
defaultOutlineColor = getcolors('black');
defaultMarkerColor = getcolors('white');

% ... fill
if any(isnan(fillColor(:))) || isempty(fillColor)
    if nParameters <= size(defaultFillColors,1)
        fillColors = defaultFillColors(1:nParameters,:);
    else
        fillColors = repmat(defaultFillColor,[nParameters 1]);
    end
else
    if size(fillColor,1)==1
        fillColors = repmat(fillColor,[nParameters 1]);
    elseif size(fillColor,1)==nParameters
        fillColors = fillColor;
    else
        error('fillColor has invalid number of rows.')
    end
end
% ... fill alpha
if isscalar(fillAlpha)
    fillAlpha = repmat(fillAlpha,[nParameters 1]);
elseif ~isequal(length(fillAlpha),nParameters)
    error('the lenght of fillAlpha does not match the number of parameters.')
end
% ... outline
if any(isnan(outlineColor(:))) || isempty(outlineColor)
    outlineColors = repmat(defaultOutlineColor,[nParameters 1]);
else
    if size(outlineColor,1)==1
        outlineColors = repmat(outlineColor,[nParameters 1]);
    elseif size(outlineColor,1)==nParameters
        outlineColors = outlineColor;
    else
        error('outlineColor has invalid number of rows.')
    end
end
% ... marker
if any(isnan(markerColor(:))) || isempty(markerColor)
    markerColors = repmat(defaultMarkerColor,[nParameters 1]);
else
    if size(markerColor,1)==1
        markerColors = repmat(markerColor,[nParameters 1]);
    elseif size(markerColor,1)==nParameters
        markerColors = markerColor;
    else
        error('markerColor has invalid number of rows.')
    end
end

%% precompute densities, etc.
%(important to establish height/width beforehand!)
%only bother doing these computations/this loop once!
precomputed = table('size',[nParameters 8], ...
    'VariableTypes',{'cell','cell','double','double','cell','cell','cell','cell'}, ...
    'VariableNames',{'x','f','mean','median','CI95','CI50','violinBounds','shadeBounds'});

proportion95 = 0.95;%min(0.95,outline);
proportion50 = 0.50;%min(0.50,outline);

minX = NaN; maxX = NaN; maxF = 0;
for n = 1:nParameters
    %account for parameters vs. parameter instances
    if isInstance(n)
        [parameter,ind] = str2ind(parameters{n});
        chains = samples.(parameter)(:,:,ind{:});
    else
        parameter = parameters{n};
        chains = samples.(parameter);
    end
    chains = chains(:);
    %get a smoothed marginal density and scale it
    [precomputed.f{n},precomputed.x{n}] = smoothdensity(chains);
    maxF = max(max(precomputed.f{n}),maxF);
    %point estimates
    precomputed.mean(n) = mean(chains);
    precomputed.median(n) = median(chains);
    %credible intervals
    precomputed.CI95{n} = computecredint(chains,proportion95);
    precomputed.CI50{n} = computecredint(chains,proportion50);
    %plotting intervals
    if outline > 0
        precomputed.violinBounds{n} = computecredint(chains,outline);
        minX = min(min(precomputed.violinBounds{n}),minX);
        maxX = max(max(precomputed.violinBounds{n}),maxX);
    end
    if shading > 0
        precomputed.shadeBounds{n} = computecredint(chains,shading);
        minX = min(min(precomputed.shadeBounds{n}),minX);
        maxX = max(max(precomputed.shadeBounds{n}),maxX);
    end
end

%% make horizontal density plot
%start a figure ...
dumf = figure(999); %dummy figure to protect sizing
f = figure('color',[1 1 1]);
fpos = f.Position;
f.Position = [fpos([1 2]) [580 300]*figScaling];
close(dumf.Number); %close dummy figure
%... and an axis
hold on

%what proportion of vertical space should be taken up by the intervals?
if addInterval
    maxDrop = maxF*0.05*(2+log(nParameters+2));
    droppedPos = linspace(0,-maxDrop,nParameters+2);
    dropBuffer = abs(mean(droppedPos(1:2)));
    droppedPos = droppedPos - dropBuffer;
    maxDrop = maxDrop + 2*dropBuffer;
end

%underlay a line at the critical value
if ~isnan(criticalValue)
    line(criticalValue*[1 1],[-2*maxF maxF*2], ...
        'color',0.25*[1 1 1],'linestyle','-')
end

%dummy handles
h = gobjects([1 nParameters]);
for n = 1:nParameters
    h(n) = fill([0 1 1 0 0], maxF*[-2 -2 -2.1 -2.1 -2],fillColors(n,:), ...
        'edgecolor',outlineColors(n,:),'facealpha',fillAlpha(n));
end

for n = 1:nParameters
    %extract precomputed values
    x = precomputed.x{n}; m = precomputed.mean(n);     CI50 = precomputed.CI50{n};
    f = precomputed.f{n}; mdn = precomputed.median(n); CI95 = precomputed.CI95{n};
    %underline
    if addInterval
        plot([minX-(maxX-minX) maxX+(maxX-minX)],[0 0],'-', ...
            'color',0.9*[1 1 1])    
    end
    %shade inside the density
    if shading > 0 && shading < 1
        shadeBounds = precomputed.shadeBounds{n};
        inShading = x>=shadeBounds(1) & x<=shadeBounds(2);
    else
        inShading = true(size(x));
    end
    if shading > 0
        for side = [-1 1]
            fs = f(inShading); xs = x(inShading);
            %(duping start and end values in fill to ensure that the shape is 
            %closed if up even if most values are against an end boundary)
            fill([xs(1)-eps xs xs(end)+eps],[0 fs 0],fillColors(n,:), ...
                'edgecolor','none','facealpha',fillAlpha(n))
        end
    end
    %outline the density
    if outline > 0 && outline < 1
        violinBounds = precomputed.violinBounds{n};
        inOutline = x>=violinBounds(1) & x<=violinBounds(2);
    else
        inOutline = true(size(x));
    end
    if outline > 0
        fv = f(inOutline); xv = x(inOutline);
        %outline top of curve
        plot(xv,fv,'color',outlineColors(n,:))%,'linewidth',linePt)
%         %outline bottom of curve
%         plot([xv(1) xv(end)],[0 0], ...
%             'color',outlineColors(n,:))%,'linewidth',linePt)
%         %connect top outline to bottom at L & R ends
%         plot(xv(1)*[1 1],[0 fv(1)], ...
%             'color',outlineColors(n,:))%,'linewidth',linePt)
%         plot(xv(end)*[1 1],[0 fv(end)], ...
%             'color',outlineColors(n,:))%,'linewidth',linePt)
    end
    %overlay point estimate (dashed line)
    if addEstimate
        [~,indMean] = min(abs(x-m));%get closest function height
        plot(m*[1 1],[0 f(indMean)],':','color',outlineColors(n,:))
    end
    %overlay (with drop offset) ...
    if addInterval
        %... 95% credible interval (thin line)
        plot(CI95,(droppedPos(n+1))*[1 1], ...
            'color',outlineColors(n,:),'linewidth',0.5)
        %... 50% credible interval (thick line)
        plot(CI50,(droppedPos(n+1))*[1 1], ...
            'color',outlineColors(n,:),'linewidth',linePt*4)
        %... median (marker)
        plot(mdn,(droppedPos(n+1)),'o','markersize',linePt*4, ...
            'markerfacecolor',markerColors(n,:), ...
            'markeredgecolor',outlineColors(n,:))
    end
end
%format plot
if nargout==0
    legend(h,parameters,'interpreter','none','box','off')
end
if ~isnan(criticalValue)
    if criticalValue > maxX, maxX = criticalValue; end
    if criticalValue < minX, minX = criticalValue; end
end
bufferX = 0.05*(maxX-minX);
xlim([minX-bufferX maxX+bufferX])
if addInterval
    set(gca,'ylim',[-maxDrop 1.2*maxF])
    yt = get(gca,'ytick');
    set(gca,'ytick',yt(yt>=0))
else
    set(gca,'ylim',[-0 1.1*maxF])
end
set(gca,'ticklabelinterpreter','none')
set(gca,'box','on','fontsize',fontSz)

%% output
if nargout==0
    %no output
elseif nargout==1
    varargout{1} = h;
else
    error('too many outputs.')
end

end