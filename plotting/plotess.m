function plotess(samples,diagnostics,parameterRequest,varargin)
%PLOTESS generates a duo of diagnostic effective sample size (ESS) plots. 
% 
% this function generates figures with the new diagnostic plots based on
% effective sample size (ESS) estimates recommended by Vehtari et al.
% (2020).  one multipanel figure is generated for each parameter instance. 
% 
% the three types of diagnostic ESS plots are:
%   (1) the "efficiency per iteration" or "evolution" plot
%       >>> if the marginal posterior distribution has been efficiently
%           explored, then ESS estimates should grow linearly with the
%           number of samples.  
%           be wary if ESS estimates level off or decrease.  (some sampling
%           inefficiencies may only become evident when sufficiently long
%           chains are run.) 
%         > the dashed line represents the minimum ESS, 100*(number of
%           chains). 
%   (2) the "efficiency of quantile estimates" or "quantile" plot
%       ... which is very similar to ...
%   (3) the "local efficiency of small-interval probability estimates" 
%         or "local" plot 
%       >>> visualizing whether ESS is notably lower for some quantiles or
%           local regions (e.g., lower ESS over extreme quantiles),
%           especially if those quantiles or intervals of quantiles seem to
%           correlate with divergent transitions or hitting max tree depth,
%           can help identify what areas of the marginal posterior are
%           driving low ESS. 
%         > the dashed line represents the minimum ESS, 100*(number of
%           chains). 
%         > diagnostic quantites will be represented as rugplots along the
%           bottom of the plot (beneath the solid black line representing
%           ESS = 0). the rug plot representing divergent transitions (if
%           any) will be indicated in red, while the rug plot representing
%           that the max treedepth was hit (if it was) will be indicated in
%           orange. (if neither diagnostic was problematic, no rug plot is
%           included.)  
%         > rug plots in the gray area at the bottom of the plot (beneath
%           the solid black line representing ESS = 0) mark the quantiles
%           of samples where diagnostic quantities indicated problematic
%           sampling.  the rug plot representing divergent transitions (if
%           any) will be plotted in red, while the rug plot representing
%           that the max treedepth was hit (if it was) will be plotted in
%           orange.  (if neither diagnostic was problematic, no rug plot is
%           included.) 
% each figure will include an 'evolution' subplot and a 'local' subplot.
% 
% NOTE: a maximum of 25 figures may be generated in a single call, to
%       mitigate the risk of memory overload.  
% 
% 
% PLOTESS(SAMPLES,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of poserior samples in the format 
%   generated by extractsamples.m.  
%   
%   PARAMETERREQUEST is a parameter name string or cell of parameter
%   name strings for which the function should generates a figure for [each
%   instance of] each of those parameters.
%   if PARAMETERREQUEST is empty, all parameters & instances are requested. 
%   PARAMETERREQUEST may include specific parameter instances, by 
%   including a valid index or indices in brackets after the parameter 
%   name (e.g., 'mu[3]','sigma[2,1]').  wildcards may also be used to 
%   select a subset of instances of a given parameter (e.g.,
%   'sigma[2,*]').
% 
% 
% optional inputs may be given as property name-value pairs:
% PLOTESS(SAMPLES,DIAGNOSTICS,PARAMETERREQUEST, ...
%                           'name1',VALUE1,'name1',VALUE2,...)
% pairs may be given in any order.  property names are case insensitive.
%   
%   'max_depth'
%       if a maximum tree depth other than NUTS' default value of 10 was
%       used during sampling, then MAX_DEPTH should be used to give this
%       value as a single positive integer.    
%       the default value for MAX_DEPTH is 10.
%   
%   'plottypes'
%       PLOTTYPES determines what ESS plot types to include in each figure.
%       valid PLOTTYPES are: 'evolution','quantile', and 'local' (as
%       described above). PLOTTYPES must be given as a string or cell of
%       strings, and cannot be empty.  
%       the default value for PLOTYPES is {'evolution','local'}.
%   
%   'numpoints'
%       NUMPOINTS is the maximum number of points on an ESS evolution plot, 
%         AND the number of quantiles on an ESS quantile plot, 
%         AND the number of intervals on an ESS local small-interval plot.  
%       NUMPOINTS must be an integer and must be at least 4. 
% 
% 
% Reference:  Vehtari, Gelman, Simpson, Carpenter, BÃ¼rkner (2020). 
%                   Rank-normalization, folding, and localization: An
%                   improved R^ for assessing convergence of MCMC.  ArXiv.
% 
% 
% See also COMPUTEESS, RANKPLOTS, ESSEFFICIENCYPLOT, ESSQUANTILEPLOT, ESSINTERVALPLOT
% 
% (c) beth baribault 2021 ---                                 > matstanlib

msl.options

%% parse required inputs
if nargin < 2
    error('too few inputs.')
end

%samples
if ~isstruct(samples)
    error('first input must be a structure of posterior samples.')
else
    %extract size info immediately
    allFields = fieldnames(samples);
    [nIterations,nChains] = size(samples.(allFields{1}),[1 2]);
    nSamples = nIterations*nChains;
end

%diagnostics
if ~isstruct(diagnostics)
    error(['second input must be the diagnostics structure ' ...
        '(consisitent with the output of extractsamples.m).'])
else
    if ~all(isfield(diagnostics,{'divergent__','treedepth__'}))
        error(['second input must be the diagnostics structure, but the ' ...
            'structure given doesn''t have the ''divergent__'' and/or ' ...
            '''treedepth__'' fields.'])
    end
    %extract diagnostic fields immediately
    divergent = diagnostics.divergent__;
    treedepth = diagnostics.treedepth__;
end

%parameterRequest
if nargin < 3 || isempty(parameterRequest)
    parameterRequest = fieldnames(samples);
elseif ~(iscell(parameterRequest) && all(cellfun(@ischar,parameterRequest)))
    if ischar(parameterRequest)
        parameterRequest = {parameterRequest};
    else
        error(['parameterRequest must be a string or cell of strings ' ...
               'containing valid parameter or instance name strings.'])
    end
end

%% parse optional inputs
%ensure all remaining inputs are consistent with name-value pair format
if mod(length(varargin),2) > 0 || ...
        ~all(cellfun(@ischar,varargin(1:2:length(varargin))))
    error(['all inputs (after samples and parameterRequest) ' ...
        'must be submitted as name-value pairs.'])
elseif length(unique(varargin(1:2:length(varargin))))<length(varargin(1:2:length(varargin)))
    error('at least one property name (in the name-value pair inputs) is a duplicate.')
end

%set default values for the optional inputs
nPoints = 20;                      minNpoints = 4;
plotTypes = {'evolution','local'}; validPlotTypes = {'evolution','quantile','local'};
maxTD = 10;

varargin(1:2:length(varargin)) = ... %case insensitive (convert all to lower case)
    cellfun(@lower,varargin(1:2:length(varargin)),'uni',0);
for v = 1:2:length(varargin)
    switch varargin{v}
        %----------------------------------------------------------------%
        case 'max_depth'
            maxTD = varargin{v+1};
            if ~isnumeric(maxTD) || ~isscalar(maxTD) || ...
                    ~isequal(mod(maxTD,1),0) || maxTD < 1
                error('max_depth must be a single positive integer.')
            end
        %----------------------------------------------------------------%
        case 'npoints'
            nPoints = varargin{v+1};
            if ~isnumeric(nPoints) || ~isscalar(nPoints) || ...
                    ~isequal(mod(nPoints,1),0) 
                error('nPoints must be a single integer.')
            elseif nPoints < minNpoints
                error('nPoints must be at least %i.',minNpoints)
            end
        %----------------------------------------------------------------%
        case 'plottypes'
            plotTypes = varargin{v+1};
            if ischar(plotTypes)
                plotTypes = {plotTypes};
            end
            if ~iscell(parameterRequest) || ~all(cellfun(@ischar,parameterRequest))
                error(['plotTypes must be a string (@ischar==true) ' ...
                    'or cell of strings .'])
            elseif ~all(ismember(plotTypes,validPlotTypes))
                error(['plotTypes includes strings that are not valid ' ...
                    'inputs. valid inputs include: ''%s''.'], ...
                    strjoin(validPlotTypes,''', '''))
            else
                plotTypes = unique(plotTypes,'stable');
                if length(plotTypes) < 1 || length(plotTypes) > 3
                    error('can only have between 1 and 3 unique plot types.')
                end
            end
        %----------------------------------------------------------------%
        otherwise
            error('the optional input name ''%s'' was not recognized.', ...
                varargin{v})
    end
end

%% prepare to generate plots
ESStypes = {'bulk','tail'};
ESScolors = getcolors('blue','lightblue');

divergentColor = getcolors('red');
treedepthColor = getcolors('orange');

%maximum number of figures to generate
maxNfigures = 25;

%create a list of parameter instances
parameters = getparaminstances(parameterRequest, ...
    fieldnames(samples),struct2cell(structfun(@size,samples,'uni',0)));

%warn if over the figure limit
if length(parameters) > maxNfigures
    warning(['requested %i traceplots, but this function will only ' ...
        'generate up to %i traceplots in a single call (to protect ' ...
        'against memory overload and subsequent freezing). ' ...
        'try requesting fewer parameters/parameter instances.  ' ...
        'continuing to generate the first %i traceplots now ...'], ...
        length(parameters),maxNfigures,maxNfigures)
end

%a quick dummy plot (to get nicer x-axis ticks)
dumf = figure;
plot(1:nSamples)
xt = get(gca,'xtick');
if xt(1)==0, xt(1) = []; end
close(dumf.Number)

%prepare for diagnostic overlays
%convert treedepth to an indicator of hitting max tree depth
treedepth = treedepth==maxTD;
%which diagnostics to plot?
quantities = [1 2];
if ~any(divergent(:)), quantities(1) = 0; end
if ~any(treedepth(:)), quantities(2) = 0; end
quantities(quantities==0) = [];

%% prepare for ESS plots

nPanels = length(plotTypes);

nBatches   = nPoints; %maximum
nQuantiles = nPoints;
nIntervals = nPoints;

%prepare for each plot type
for plt = 1:nPanels
  switch plotTypes{plt}
    %--------------------------------------------------------------------%
    case 'evolution'    %%%% nBatches, firstIter, lastIter %%%
        %minimum quantites for plot
        minNbatches = minNpoints;
        minSamplesPerBatch = 100;
        %determine how many iterations to include in each batch
        batchOK = false;
        while ~batchOK
            nItersPerBatch = floor(nIterations/nBatches);
            if nItersPerBatch*nChains >= minSamplesPerBatch
                batchOK = true;
            else
                nBatches = nBatches - 2;
                if nBatches < minNbatches
                    error('need at least %i samples total to make this plot.', ...
                        minNbatches*minSamplesPerBatch)
                end
            end
        end
        batchIters = nIterations:-nItersPerBatch:0; %endpoints of equally-sized 
        batchIters = batchIters(end:-1:1);          %batches ... in order
        firstIter = batchIters(1)+1;        %iter to start ALL batches
        lastIter =  batchIters(2:end);      %iter to end EACH batch
        nBatches = length(lastIter);
    %--------------------------------------------------------------------%
    case 'quantile'     %%% nQuantiles, Quantiles, %%%
        %which quantiles to plot?
        xQuantiles = linspace(0.5/nQuantiles,1-0.5/nQuantiles,nQuantiles);
    %--------------------------------------------------------------------%
    case 'local'        %%%% nIntervals, xIntervals %%%
        %what local quantile intervals to plot?
        xIntervals = linspace(0.001,0.999,nIntervals+1);
        xIntervalPos = [xIntervals(1) repelem(xIntervals(2:end-1),2) xIntervals(end)];
  end
end

%% make a figure (with 1+ ESS plot panels) for each parameter

%make each subplot
isInstance = cellfun(@(x) any(x=='['),parameters);
for p = 1:min([length(parameters),maxNfigures])
  %start a figure ...
  dumf = figure(999); %dummy figure to protect sizing
  f = figure('color',[1 1 1]);
  fpos = f.Position;
  f.Position = [fpos(1:2) [50+500*nPanels 380]*figScaling];
  close(dumf.Number); %close dummy figure
  %... and a layout ...
  tiledlayout(1,nPanels,'tilespacing','compact','padding','compact');
  for plt = 1:nPanels
    %account for parameters vs. parameter instances
    if isInstance(p)
        [parameter,ind] = str2ind(parameters{p});
        chains = samples.(parameter)(:,:,ind{:});
    else
        parameter = parameters{p};
        chains = samples.(parameter);
    end
    %select plot type
    switch plotTypes{plt}
    %--------------------------------------------------------------------%
      case 'evolution'
        %start an axis
        nexttile; hold on
        
        %%% underlay lines at ESS criterion
        plot([1 nSamples],nChains*100*[1 1],'k--')
        
        %%% plot efficiency per iteration
        h = gobjects([1 length(ESStypes)]);
        ESSbyIter = NaN([1 nBatches]);
        for c = 1:length(ESStypes)
            ESStype = ESStypes{c};
            for n = 1:nBatches
                thisBatch = firstIter:lastIter(n);
                ESSbyIter(n) = computeess(chains(thisBatch,:),ESStype);
            end        
            h(c) = plot(lastIter*nChains,ESSbyIter,'-o', ...
                'color',ESScolors(c,:),'markerfacecolor',ESScolors(c,:), ...
                'linewidth',linePt*2);
        end
        
        %%% format
        xlim([1 nSamples])
        set(gca,'xtick',xt)
        yl = get(gca,'ylim'); yl = [0 max([yl(2) 1.1*100*nChains])]; set(gca,'ylim',yl)
        yt = get(gca,'ytick'); yt(yt<0) = []; set(gca,'ytick',yt)
        xlabel('total number of draws')
        ylabel('ESS')
        title(parameters{p},'interpreter','none')
        legend(h,ESStypes, ...
            'location','southoutside','orientation','horizontal')
        set(gca,'fontsize',fontSz,'box','on')
      %------------------------------------------------------------------%
      case 'quantile'
        %start an axis
        nexttile; hold on
        
        %%% underlay lines at ESS criteria
        plot([-1 2],nChains*100*[1 1],'k--')
        plot([-1 2],[0 0],'k-')
        
        %%% plot efficiency per iteration
        ESSbyQuantile = NaN([1 length(xQuantiles)]);
        for n = 1:length(xQuantiles)
            ESSbyQuantile(n) = computeess(chains,'quantile',xQuantiles(n));
        end
        plot(xQuantiles,ESSbyQuantile,'ko', ...
            'markerfacecolor','k','markersize',markSz*0.65);
        
        %%% rug plots (plot divergences, hit max treedepth) %%%
        yl = ylim; set(gca,'ylim',[0 max([nSamples yl(2)])])
        addrugplot(nSamples,markSz,quantities, ...
                    divergent,treedepth,divergentColor,treedepthColor)
        
        %%% format
        xlim([0 1])
        yt = get(gca,'ytick'); yt(yt<0) = []; set(gca,'ytick',yt)
        xlabel('quantile')
        ylabel('ESS for quantiles')
        title(parameters{p},'interpreter','none')
        set(gca,'fontsize',fontSz,'box','on')
        
      %------------------------------------------------------------------%
      case 'local'
        %start an axis
        nexttile; hold on
        
        %%% underlay lines at ESS criteria
        plot([-1 2],nChains*100*[1 1],'k--')
        plot([-1 2],[0 0],'k-')

        %%% plot efficiency per iteration
        ESSbyQuantile = NaN([1 nIntervals]);
        for n = 1:nIntervals
            ESSbyQuantile(n) = computeess(chains,'local',xIntervals(n:n+1));
        end
        %light vertical lines at interval borders
        plot(xIntervalPos,repelem(ESSbyQuantile,2),'-', ...
            'linewidth',linePt*1,'color',0.95*[1 1 1])
        %horizontal over each interval
        for n = 1:nIntervals
            plot(xIntervals(n:n+1),ESSbyQuantile(n)*[1 1],'-', ...
                'linewidth',linePt*1.5,'color','k')
        end
        
        %%% rug plots (plot divergences, hit max treedepth) %%%
        yl = ylim; set(gca,'ylim',[0 max([nSamples yl(2)])])
        addrugplot(nSamples,markSz,quantities, ...
                    divergent,treedepth,divergentColor,treedepthColor)
        
        %%% format
        xlim([0 1])
        yt = get(gca,'ytick'); yt(yt<0) = []; set(gca,'ytick',yt)
        xlabel('quantile')
        ylabel('ESS for local intervals')
        title(parameters{p},'interpreter','none')
        set(gca,'fontsize',fontSz,'box','on')
  end
 end
end

end

%% -------------------------------------------------------------------- %%
function addrugplot(nSamples,markSz,quantities, ...
                    divergent,treedepth,divergentColor,treedepthColor)
    %%% rug plots (plot divergences, hit max treedepth) %%%
    %expand the y-axis to fit the diagnostics
    xl = xlim;
    yl = ylim;
    barMarkerSz = markSz*0.75;
    rug_pos(1) = -0.0065*barMarkerSz*diff(yl);
    rug_pos(2) = -0.0165*barMarkerSz*diff(yl);
    rug_pos(3) = -0.0265*barMarkerSz*diff(yl);
    %underlay light gray
    fill([-1 2 2 -1],[0 0 -yl(2) -yl(2)],0.95*[1 1 1])
    %make one rugplot per diagnostic
    c = 0;
    for q = quantities
        if     q==1, dx = divergent; dxColor = divergentColor;
        elseif q==2, dx = treedepth; dxColor = treedepthColor;
        end
        %convert from chains to quantiles
        qEdges = 0:0.0001:1;
        qValues = quantile(chains(:),qEdges);
        inQtls = discretize(chains(find(dx)),[-inf qValues(2:end-1) inf]);
        %rug plot
        c = c + 1; %increment counter
        x_dx = qEdges(inQtls);
        y_dx = rug_pos(c)*ones(size(x_dx));
        plot(x_dx,y_dx,'|','markersize',barMarkerSz,'color',dxColor)
    end
    if c==0, c = 1; end
    %reestablish limits, just to be sure
    xlim(xl); ylim([sum(rug_pos(c:c+1).*[1 2])/3 yl(2)]);
end
