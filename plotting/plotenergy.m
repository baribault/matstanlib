function plotenergy(diagnostics,method)
%PLOTENERGY generates a diagnostic energy plot for HMC-NUTS sampling.
% 
% NOTE: this is only applicable to output from to HMC sampling algorithms.
% 
% this function presents an energy diagnostic plot for each chain in a 
% separate subplot in a single figure. 
% 
% if the distribution of marginal energy (pi_E) and the distribution of 
% the changes in energy (pi_DeltaE) looks dissimilar, and/or if the
% estimated Bayesian fraction of missing information (BFMI) for any chain
% is below 0.2, it suggests that sampling for that chain was problematic,
% and the output should not be trusted.  
% 
% 
% PLOTENERGY(DIAGNOSTICS)
%   DIAGNOSTICS is a structure containing Stan's diagnostic quantites 
%   (in the format generated by extractsamples.m).  
% 
% PLOTENERGY(DIAGNOSTICS,METHOD)
%   optionally, one can also specify which plotting METHOD to use:
%       'chain'   >>  one suplot per chain
%       'overall' >>  generate a single energy plot for all chains' energy
%   the default value for METHOD is 'chain'.
% 
% PLOTENERGY(ENERGY)
% PLOTENERGY(ENERGY,METHOD)
%   alternatively, the first input may be the [nIterations nChains] matrix
%   found in diagnostics.energy__.
% 
% 
% Reference:    Betancourt, M. (2016, April). Diagnosing Suboptimal
%                   Cotangent Disintegrations in Hamiltonian Monte Carlo.  
%                   ArXiv.
% 
% 
% See also COMPUTEBFMI
% 
% (c) beth baribault 2021 ---                                 > matstanlib 

msl.options

%% parse inputs
if isstruct(diagnostics)
    %actually the diagnostics structure
    if ~isfield(diagnostics,'energy__')
        error(['if input is struct-type, it must include ''energy__'' ' ...
            'as a field.'])
    end
    energy = diagnostics.energy__;
elseif isnumeric(diagnostics) && ismatrix(diagnostics)
    %actually the energy__ field of the diagnostics structure
    energy = diagnostics;
else
    error(['first input must be a structure of diagnostic quantities ' ...
        '(consisitent with the output of extractsamples.m) ' ...
        'or a matrix of energy values.'])
end

%%% optional %%%
%method
validMethods = {'chain','overall'};
if nargin < 2 || isempty(method)
    method = 'chain';
elseif ischar(method)
    if ~ismember(method,validMethods)
        error(['method input ''%s'' is not a valid string. valid options ' ...
            'include: ''%s''.'],method,strjoin(validMethods,''', '''))
    end
else
    error('method input must be string type.')
end

if nargin > 2
    error('too many inputs.')
end

%% prepare for plotting
marginalColor = getcolors('rose');
diffColor = getcolors('blend','blue','lightgray');

marginalLabel = 'marginal energy, \pi_E';
diffLabel = 'change in energy, \pi_{\Delta E}';

%% plot energy histograms

%extract size info
[~,nChains] = size(energy);

%compute estimated BFMI
BFMI = computebfmi(energy);

%generate plot(s)
switch method
  %----------------------------------------------------------------------%
  case 'chain'
    %%% one panel per chain
    %start a figure ...
    dumf = figure(999); %dummy figure to protect sizing
    f = figure('color',[1 1 1]);
    fpos = f.Position;
    f.Position = [fpos(1:2) [520 420]*figScaling];
    close(dumf.Number); %close dummy figure
    %... and a layout
    t = tiledlayout('flow','tilespacing','compact','padding','compact');
    ax = gobjects([nChains 1]);
    %one energy diagnostic plot per chain
    for m = 1:nChains
        ax(m) = nexttile; hold on;
        h = gobjects([2 1]);
        %marginal energy
        h(1) = histogram(energy(:,m) - mean(energy(:,m)),'normalization','pdf', ...
            'facecolor',marginalColor,'edgecolor',marginalColor);
        %diff energy
        h(2) = histogram(diff(energy(:,m)),'normalization','pdf', ...
            'facecolor',diffColor,'edgecolor',diffColor);
        %format
        set(gca,'ytick',[])          %y-axis is uninformative
        title(sprintf('chain %i',m),'fontweight','normal')
        set(gca,'fontsize',fontSz)
    end
    
    %format layout
    linkaxes(ax,'x') %zooming one zooms all
    t.XLabel.Interpreter = 'latex';
    t.XLabel.String = '$E - \bar{E}$';
    
    %add BFMI as a text label to each plot (must come after linkaxes)
    for m = 1:nChains
        axes(ax(m))
        xl = xlim; yl = ylim;
        text(xl(2)-0.01*diff(xl),yl(2)-0.01*diff(yl), ...
                sprintf('BFMI = %.3f',BFMI(m)), ...
                'interpreter','none','fontsize',fontSz-2, ...
                'HorizontalAlignment','right','VerticalAlignment','top')
    end

    %resize the figure based on the number of tiles
    gridSize = t.GridSize;
    f.Position = [fpos(1:2) (gridSize.*[300 185] + [0 75])*figScaling];
    
    %common legend
    lg = legend(h,marginalLabel,diffLabel, ...
                'location','northwest','fontsize',fontSz-2);
    lg.Layout.Tile = 'north';
    
    
  %----------------------------------------------------------------------%
  case 'overall'
    %%% compute within chain, then pool across chains
    %start a figure ...
    dumf = figure(999); %dummy figure to protect sizing
    f = figure('color',[1 1 1]);
    fpos = f.Position;
    f.Position = [fpos(1:2) [520 350]*figScaling];
    close(dumf.Number); %close dummy figure
    %... and a layout
    hold on
    h = gobjects([2 1]);
    %a single energy diagnostic, over all chains
    margE = NaN(size(energy));
    for m = 1:nChains
        margE = energy(:,m) - mean(energy(:,m));
    end
    diffE = diff(energy);
    %marginal energy
    h(1) = histogram(margE(:),'normalization','pdf', ...
        'facecolor',marginalColor,'edgecolor',marginalColor);
    %diff energy
    whos margE diffE
    h(2) = histogram(diffE(:),'normalization','pdf', ...
        'facecolor',diffColor,'edgecolor',diffColor);
    
    %format layout
    xlabel('$E - \bar{E}$','interpreter','latex')
    set(gca,'ytick',[])          %y-axis is uninformative
    set(gca,'fontsize',fontSz)
    legend(h,marginalLabel,diffLabel, ...
             'location','northoutside','fontsize',fontSz-2)
    
    %add BFMI *for all chains* as a text label
%     BFMIstrings = cell([nChains 1]);
%     for m = 1:nChains, BFMIstrings{m} = sprintf('%.3g',BFMI(m)); end
%     xl = xlim; yl = ylim;
%     text(xl(2)-0.01*diff(xl),yl(2)-0.01*diff(yl), ...
%             {'BFMI by chain = ',['[' strjoin(BFMIstrings,', ') ']']}, ...
%             'interpreter','none','fontsize',fontSz-2, ...
%             'HorizontalAlignment','right','VerticalAlignment','top')
    xl = xlim; yl = ylim;
    text(xl(2)-0.01*diff(xl),yl(2)-0.01*diff(yl), ...
            sprintf('lowest BFMI = %.4g',min(BFMI)), ...
            'interpreter','none','fontsize',fontSz-2, ...
            'HorizontalAlignment','right','VerticalAlignment','top')
end

end