function horzdensity(samples,parameterRequest,varargin)
%HORZDENSITY generates a plot of smoothed densities for mutiple parameters.
% 
% this function generates a single figure in which, for each parameter
% instance, a smoothed density, with the mean highlighted, is presented
% above a quantile summary bar.  on the summary bar, the thin line
% represents the central 95% credible interval, the thick line represents
% the central 50% credible interval, and the marker represents the median.
% 
% HORZDENSITY(SAMPLES,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of posterior samples in the format 
%   generated by extractsamples.m.  
%   PARAMETERREQUEST is parameter name string or cell of strings.
%   specific parameter instances (e.g., 'theta[4]') may be included. 
%   for each parameter instance, a smoothed density is added to the plot. 
% 
% 
% optional inputs may be given as property name-value pairs:
% HORZDENSITY(SAMPLES,PARAMETERREQUEST,'name1',VALUE1,'name1',VALUE2,...)
% pairs may be given in any order.  property names are case insensitive.
%   
%   'shading'
%       SHADING curtails the shading inside the violin to the bounds of 
%       the 100*SHADING% credible interval. as such, SHADING must be 
%       between 0 and 1. if SHADING is 0, then no shading is applied.
%       the default value for SHADING is 0.99.
%   
%   'outline'
%       OUTLINE curtails the outline of the violin to the bounds of the
%       100*OUTLINE% credible interval. as such, OUTLINE must be between 
%       0 and 1.  if OUTLINE is 0,then no outline is applied. 
%       the default value for OUTLINE is 0.95. 
%   
%   'addestimate'
%       ADDESTIMATE may be true or false.
%       if true, a dotted vertical line spanning the height of the density
%       will be added at the the posterior sample mean.
%       the default value for ADDESTIMATE is true.
%   
%   'addinterval'
%       ADDINTERVAL may be true or false.
%       if true, the 95% CI (as a thin line), 50% CI (as a thick line), and
%       the median (as a circular marker), will be added to the plot. this
%       interval plot is aligned to the bottom of the density.  
%       the default value for ADDINTERVAL is false.
%   
%   'truevalues'
%       TRUEVALUES is a strucutre of true values (assuming the model was
%       fit to simulated data). in TRUEVALUES, each field is a parameter
%       name, and each field's value is a numeric scalar or array of
%       values, where the dimensions match the parameter's size (array +
%       dimensions). 
%       if given, then a star marker will be added at the bottom of each
%       density at the true value for that [instance of the] parameter. 
%   
%   'criticalvalue'
%       CRITICALVALUE must be a scalar, numerical value.  
%       supplying CRITICALVALUE triggers the underlay of a vertical line
%       at the given value. 
%   
%   'fillcolor'
%       optionally, override the default fill color scheme (rainbow) by
%       including FILLCOLOR as the third input. FILLCOLOR must be a 1x3 or
%       Nx3 matrix (where N is the number of parameter instances). 
%       if FILLCOLOR is 1x3, then the same color is used for all parameter
%       instances. if FILLCOLOR is Nx3 then each row is used for each
%       successive parameter instance.
%   
%   'fillalpha'
%       override the default fill opacity (1) with a custom opacity
%       value, FILLALPHA.  FILLALPHA must be between 0 and 1.
%   
%   'outlinecolor'
%       optionally, override the default outline color scheme (all black)
%       with the color(s) given in MARKERCOLOR.  
%       the size and usage demands are the same as for FILLCOLOR.
%   
%   'markercolor'
%       optionally, override the default median marker color scheme (all
%       white) with the color(s) given in MARKERCOLOR.  
%       the size and usage demands are the same as for FILLCOLOR.
%   
%   'truecolor'
%       optionally, override the default true value marker color scheme
%       (all black) with the color(s) given in TRUECOLOR.  
%       the size and usage demands are the same as for FILLCOLOR. 
%       this property is only permissible if a 'truevalues' property-value
%       pair is also given. 
%   
%   'grid'
%       GRID indicates whether to include a soft horizontal line across the
%       plot aligned to the bottom of each density.
%       the default value for GRID is 'off'.
%   
%   'method'
%       METHOD indicates how the violin should be scaled.  
%       if METHOD is 'height', then all violins are scaled to be the equal
%       in height (i.e., the same width on the plot).
%       if METHOD is 'area', then each violins is scaled such that they are
%       equal in area (i.e., so that each violin's width is proportional to
%       its highest density *relative to* the highest density across *all*
%       violins on the plot). 
%       the default value for METHOD is 'area'.
% 
% 
% See also VIOLINDENSITY, OVERLAYDENSITY, PLOTINTERVALS, PLOTDENSITY, 
%   JOINTDENSITY, MULTIDENSITY, SMOOTHDENSITY, EXTRACTSAMPLES
% 
% (c) beth baribault 2021 ---                                 > matstanlib 

msl.options

%% parse required inputs
if nargin < 2
    error('too few inputs.')
end

%samples
if ~isstruct(samples)
    error('the first input must be a structure of mcmc samples.')
end

%parameterRequest
if isempty(parameterRequest)
    parameterRequest = fieldnames(samples);
elseif ~(iscell(parameterRequest) && all(cellfun(@ischar,parameterRequest)))
    if ischar(parameterRequest)
        parameterRequest = {parameterRequest};
    else
        error(['parameterRequest must be a string or cell of strings ' ...
               'containing valid parameter or instance name strings.'])
    end
end

%% parse optional inputs
%ensure all remaining inputs are consistent with name-value pair format
if mod(length(varargin),2) > 0 || ...
        ~all(cellfun(@ischar,varargin(1:2:length(varargin))))
    error(['all inputs (after samples and parameterRequest) ' ...
        'must be submitted as name-value pairs.'])
elseif length(unique(varargin(1:2:length(varargin))))<length(varargin(1:2:length(varargin)))
    error('at least one property name (in the name-value pair inputs) is a duplicate.')
end

%set default values for the optional inputs
shading = 0.99;
outline = 0.95;
addEstimate = true;
trueValues = NaN;               addTrueValues = false;
criticalValue = NaN;
addInterval = false;
fillColor = NaN;    %use default colors
fillAlpha = 1;
outlineColor = NaN; %use default colors
markerColor = NaN;  %use default colors
trueColor = NaN;    %use default colors
method = 'area';                validViolinMethods = {'area','height'};
gridOnOff = 'off';              validGridOnOff = {'on','off'};

varargin(1:2:length(varargin)) = ... %case insensitive (convert all to lower case)
    cellfun(@lower,varargin(1:2:length(varargin)),'uni',0);
for v = 1:2:length(varargin)
    switch varargin{v}
        %----------------------------------------------------------------%
        case 'shading'
            shading = varargin{v+1};
            if ~isnumeric(shading) || ~isscalar(shading)
                error('shading must be a single numeric value.')
            elseif shading < 0 || shading > 1
                error('shading must be a proportion between 0 and 1.')
            end
        %----------------------------------------------------------------%
        case 'outline'
            outline = varargin{v+1};
            if ~isnumeric(outline) || ~isscalar(outline)
                error('outline must be a single numeric value.')
            elseif outline < 0 || outline > 1
                error('outline must be a proportion between 0 and 1.')
            end
        %----------------------------------------------------------------%
        case 'criticalvalue'
            criticalValue = varargin{v+1};
            if ~isnumeric(criticalValue) || ~isscalar(criticalValue)
                error('criticalvalue must be a single number.')
            end
        %----------------------------------------------------------------%
        case 'addestimate'
            addEstimate = varargin{v+1};
            if ~isscalar(addEstimate) && ~ismember(addEstimate,[0 1])
                error('addEstimate must be a true/1 or false/0 value.')
            end
        %----------------------------------------------------------------%
        case 'addinterval'
            addInterval = varargin{v+1};
            if ~isscalar(addInterval) && ~ismember(addInterval,[0 1])
                error('addInterval must be a true/1 or false/0 value.')
            end
        %----------------------------------------------------------------%
        case 'truevalues'
            trueValues = varargin{v+1};
            if ~isstruct(trueValues) || ~all(structfun(@isnumeric,trueValues))
                error(['trueValues must be structure where each field ' ...
                    'is a parameter name, and each field''s value is ' ...
                    'a numeric scalar or array of true values, where ' ...
                    'the dimensions match the parameter''s array + dimensions.'])
            end
            addTrueValues = true;
        %----------------------------------------------------------------%
        case 'fillcolor'
            fillColor = varargin{v+1};
            if isscalar(fillColor) && (isnan(fillColor) || isempty(fillColor))
                %do nothing --- will use default colors
            elseif ~ismatrix(fillColor) || size(fillColor,2)~=3 
                error(['fillcolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(fillColor)))
            elseif isnumeric(fillColor)
                if ~ismatrix(fillColor) || size(fillColor,2)~=3 
                    error(['fillcolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(fillColor)))
                elseif ~all(fillColor(:)<=1) || ~all(fillColor(:)>=0) 
                    error(['each row of fillcolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('fillcolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'fillalpha'
            fillAlpha = varargin{v+1};
            if ~isnumeric(fillAlpha)
                error('fillAlpha must be a numeric value.')
            elseif isempty(fillAlpha)
                %use default
            elseif ~isvector(fillAlpha)
                error('fillAlpha must be scalar or vector.')
            elseif any(fillAlpha(:) < 0 | fillAlpha(:) > 1)
                error('fillAlpha must be between 0 and 1.')
            end
        %----------------------------------------------------------------%
        case 'outlinecolor'
            outlineColor = varargin{v+1};
            if isscalar(outlineColor) && (isnan(outlineColor) || isempty(outlineColor))
                %do nothing --- will use default color
            elseif ~ismatrix(outlineColor) || size(outlineColor,2)~=3 
                error(['outlinecolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(outlineColor)))
            elseif isnumeric(outlineColor)
                if ~ismatrix(outlineColor) || size(outlineColor,2)~=3 
                    error(['outlinecolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(outlineColor)))
                elseif ~all(outlineColor(:)<=1) || ~all(outlineColor(:)>=0) 
                    error(['each row of outlinecolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('outlinecolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'markercolor'
            markerColor = varargin{v+1};
            if isscalar(markerColor) && (isnan(markerColor) || isempty(markerColor))
                %do nothing --- will use default color
            elseif ~ismatrix(markerColor) || size(markerColor,2)~=3 
                error(['markercolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(markerColor)))
            elseif isnumeric(markerColor)
                if ~ismatrix(markerColor) || size(markerColor,2)~=3 
                    error(['markercolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(markerColor)))
                elseif ~all(markerColor(:)<=1) || ~all(markerColor(:)>=0) 
                    error(['each row of markercolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('markercolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'truecolor'
            trueColor = varargin{v+1};
            if isscalar(trueColor) && (isnan(trueColor) || isempty(trueColor))
                %do nothing --- will use default color
            elseif ~ismatrix(trueColor) || size(trueColor,2)~=3 
                error(['truecolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(trueColor)))
            elseif isnumeric(trueColor)
                if ~ismatrix(trueColor) || size(trueColor,2)~=3 
                    error(['truecolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(trueColor)))
                elseif ~all(trueColor(:)<=1) || ~all(trueColor(:)>=0) 
                    error(['each row of truecolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('truecolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'method'
            method = varargin{v+1};
            if ~ischar(method)
                error('method must be a string (@ischar==true).')
            elseif ~ismember(method,validViolinMethods)
                error(['violin method input is not valid. valid inputs ' ...
                    'include: ''%s''.'],strjoin(validViolinMethods,''', '''))
            end
        %----------------------------------------------------------------%
        case 'grid'
            gridOnOff = varargin{v+1};
            if ~ischar(gridOnOff)
                error('grid must be a string (@ischar==true).')
            elseif ~ismember(gridOnOff,validGridOnOff)
                error('grid input is not valid. valid inputs include: %s.', ...
                    ['''' strjoin(validGridOnOff,''', ''') ''''])
            end
        %----------------------------------------------------------------%
        otherwise
            error('the optional input name ''%s'' was not recognized.', ...
                varargin{v})
    end
end

if size(trueColor,2)==3 && ~addTrueValues
    error(['trueColor was given, but no structure of trueValues ' ...
        'to display in that color was given.'])
end

%% create a list of parameter instances
parameters = getparaminstances(parameterRequest, ...
    fieldnames(samples),struct2cell(structfun(@size,samples,'uni',0)));
isInstance = cellfun(@(x) any(x=='['),parameters);
nParameters = length(parameters);

%% get some nice colors for plotting

defaultFillColor = getcolors('paleblue');
defaultOutlineColor = getcolors('black');
defaultMarkerColor = getcolors('white');
defaultTrueColor = getcolors('black');

% ... fill
if any(isnan(fillColor(:))) || isempty(fillColor)
    fillColors = repmat(defaultFillColor,[nParameters 1]);
else
    if size(fillColor,1)==1
        fillColors = repmat(fillColor,[nParameters 1]);
    elseif size(fillColor,1)==nParameters
        fillColors = fillColor;
    else
        error('fillColor has invalid number of rows.')
    end
end
% ... fill alpha
if isscalar(fillAlpha)
    fillAlphas = repmat(fillAlpha,[nParameters 1]);
elseif isequal(length(fillAlpha),nParameters)
    fillAlphas = fillAlpha;
else
    error('the length of fillAlpha does not match the number of parameters.')
end
% ... outline
if any(isnan(outlineColor(:))) || isempty(outlineColor)
    outlineColors = repmat(defaultOutlineColor,[nParameters 1]);
else
    if size(outlineColor,1)==1
        outlineColors = repmat(outlineColor,[nParameters 1]);
    elseif size(outlineColor,1)==nParameters
        outlineColors = outlineColor;
    else
        error('outlineColor has invalid number of rows.')
    end
end
% ... marker
if any(isnan(markerColor(:))) || isempty(markerColor)
    markerColors = repmat(defaultMarkerColor,[nParameters 1]);
else
    if size(markerColor,1)==1
        markerColors = repmat(markerColor,[nParameters 1]);
    elseif size(markerColor,1)==nParameters
        markerColors = markerColor;
    else
        error('markerColor has invalid number of rows.')
    end
end
% ... trueColor
if any(isnan(trueColor(:))) || isempty(trueColor)
    trueColors = repmat(defaultTrueColor,[nParameters 1]);
else
    if size(trueColor,1)==1
        trueColors = repmat(trueColor,[nParameters 1]);
    elseif size(trueColor,1)==nParameters
        trueColors = trueColor;
    else
        error('trueColor has invalid number of rows.')
    end
end

%% reverse (plot top to bottom, but without flipping the curves!)
parameters = parameters(end:-1:1);
isInstance = isInstance(end:-1:1);
fillColors = fillColors(end:-1:1,:);
fillAlphas = fillAlphas(end:-1:1,:);
outlineColors = outlineColors(end:-1:1,:);
markerColors = markerColors(end:-1:1,:);
trueColors = trueColors(end:-1:1,:);

%% precompute densities, etc.
%(important to establish height/width beforehand!)
%only bother doing these computations/this loop once!
precomputed = table('size',[nParameters 9], ...
    'VariableTypes',{'cell','cell','double','double','double','cell','cell','cell','cell'}, ...
    'VariableNames',{'x','f','mean','median','true','CI95','CI50','violinBounds','shadeBounds'});

proportion95 = 0.95;%min(0.95,outline);
proportion50 = 0.50;%min(0.50,outline);

minX = NaN; maxX = NaN; maxF = 0;
for n = 1:nParameters
    %account for parameters vs. parameter instances
    if isInstance(n)
        [parameter,ind] = str2ind(parameters{n});
        chains = samples.(parameter)(:,:,ind{:});
        if addTrueValues
            if ~isfield(trueValues,parameter)
                error(['parameter ''%s'' was not a field in the ' ...
                    'given trueValues structure.'],parameter)
            end
            trueVal = trueValues.(parameter)(ind{:});
        end
    else
        parameter = parameters{n};
        chains = samples.(parameter);
        if addTrueValues
            trueVal = trueValues.(parameter);
        end
    end
    chains = chains(:);
    %get a smoothed marginal density and scale it
    [precomputed.f{n},precomputed.x{n}] = smoothdensity(chains);
    maxF = max(max(precomputed.f{n}),maxF);
    %point estimates
    precomputed.mean(n) = mean(chains);
    precomputed.median(n) = median(chains);
    %credible intervals
    precomputed.CI95{n} = computecredint(chains,proportion95);
    precomputed.CI50{n} = computecredint(chains,proportion50);
    %plotting intervals
    if outline > 0
        precomputed.violinBounds{n} = computecredint(chains,outline);
        minX = min(min(precomputed.violinBounds{n}),minX);
        maxX = max(max(precomputed.violinBounds{n}),maxX);
    end
    if shading > 0
        precomputed.shadeBounds{n} = computecredint(chains,shading);
        minX = min(min(precomputed.shadeBounds{n}),minX);
        maxX = max(max(precomputed.shadeBounds{n}),maxX);
    end
    if addTrueValues
        precomputed.true(n) = trueVal;
    end
end

%% make horizontal density plot
%start a figure ...
dumf = figure(999); %dummy figure to protect sizing
f = figure('color',[1 1 1]);
fpos = f.Position;
f.Position = [fpos([1 2]) [580 100+40*(nParameters)]*figScaling];
close(dumf.Number); %close dummy figure
%... and an axis
hold on

%what proportion of vertical space should be taken up by ...
% drop = 0.05;        % ... the caterpillar?
% scaleF = 0.85;      % ... the density (at maximum height)?
drop = 0;           % ... the caterpillar?
scaleF = 0.95;      % ... the density (at maximum height)?

%underlay a line at the critical value
if ~isnan(criticalValue)
    line(criticalValue*[1 1],[-2 nParameters+2], ...
        'color',0.25*[1 1 1],'linestyle',':')
end

if (scaleF+drop)>1, error('scaleF & drop cannot sum to  > 1.'); end
for n = 1:nParameters
    %extract precomputed values
    x = precomputed.x{n}; m = precomputed.mean(n);     CI50 = precomputed.CI50{n};
    f = precomputed.f{n}; mdn = precomputed.median(n); CI95 = precomputed.CI95{n};
    if addTrueValues, tr = precomputed.true(n); end
    %get a smoothed marginal density and scale it
    switch method
        case 'area'
            f = scaleF*f/maxF;      %%%%% all density heights on the same scale
        case 'height'
            f = scaleF*f/max(f);    %%%%% scale each density to its own max height
    end
    %shade inside the density
    if shading > 0 && shading < 1
        shadeBounds = precomputed.shadeBounds{n};
        inShading = x>=shadeBounds(1) & x<=shadeBounds(2);
    else
        inShading = true(size(x));
    end
    if shading > 0
        for side = [-1 1]
            fs = f(inShading); xs = x(inShading);
            %(duping start and end values in fill to ensure that the shape is 
            %closed if up even if most values are against an end boundary)
            fill([xs(1)-eps xs xs(end)+eps],[n n+fs n],fillColors(n,:), ...
                'facealpha',fillAlphas(n),'edgecolor','none')
        end
    end
    %outline the density
    if outline > 0 && outline < 1
        violinBounds = precomputed.violinBounds{n};
        inOutline = x>=violinBounds(1) & x<=violinBounds(2);
    else
        inOutline = true(size(x));
    end
    if outline > 0
        fv = f(inOutline); xv = x(inOutline);
        %outline top of curve
        plot(xv,n+fv,'color',outlineColors(n,:))%,'linewidth',linePt)
        %outline bottom of curve
        plot([xv(1) xv(end)],[n n], ...
            'color',outlineColors(n,:))%,'linewidth',linePt)
%         %connect top outline to bottom at L & R ends
%         plot(xv(1)*[1 1],[n n+fv(1)], ...
%             'color',outlineColors(n,:))%,'linewidth',linePt)
%         plot(xv(end)*[1 1],[n n+fv(end)], ...
%             'color',outlineColors(n,:))%,'linewidth',linePt)
    end
    %overlay point estimate (dashed line)
    if addEstimate
        [~,indMean] = min(abs(x-m));%get closest function height
        plot(m*[1 1],[n n+f(indMean)],'-','color',outlineColors(n,:))
    end
    %overlay true value (star marker, at bottom)
    if addTrueValues
        plot(tr,n, ...
            'marker','p','markersize',markSz*1.25, ...
            'markerfacecolor',trueColors(n,:),'markeredgecolor',trueColors(n,:))
    end
    %overlay (with drop offset) ...
    if addInterval
        %... 95% credible interval (thin line)
        plot(CI95,(n-drop)*[1 1], ...
            'color',outlineColors(n,:),'linewidth',0.5)
        %... 50% credible interval (thick line)
        plot(CI50,(n-drop)*[1 1], ...
            'color',outlineColors(n,:),'linewidth',linePt*4)
        %... median (marker)
        plot(mdn,(n-drop),'o','markersize',linePt*4, ...
            'markerfacecolor',markerColors(n,:), ...
            'markeredgecolor',outlineColors(n,:))
    end
end
%format plot
if ~isnan(criticalValue)
    if criticalValue > maxX, maxX = criticalValue; end
    if criticalValue < minX, minX = criticalValue; end
end
bufferX = 0.05*(maxX-minX);
xlim([minX-bufferX maxX+bufferX])
set(gca,'ylim',[1-0.25 nParameters+scaleF+0.2], ...
    'ytick',1:nParameters,'yticklabels',parameters)
set(gca,'ticklabelinterpreter','none')
set(gca,'ygrid',gridOnOff,'box','on','fontsize',fontSz)

end