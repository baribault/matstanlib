function varargout = plotintervals(samples,parameterRequest,varargin)
%PLOTINTERVALS plots credible interval caterpillars for multiple parameter instances.
% 
% this function generates a figure containing a caterpillar plot for all  
% instances of a single parameter.  circular markers represent point
% estimates (namely, posterior sample means). thick and thin horizontal
% lines represent central 50% and 95% credible intervals, respectively. 
% 
% PLOTINTERVALS(SAMPLES,PARAMETER)
%   SAMPLES is assumed to be a strucutre of posterior samples in the format 
%   generated by extractsamples.m.  
%   PARAMETER is a parameter name string which must be an exact match
%   for a field name in SAMPLES. each instance of that parameter will be 
%   represented as a horizontal line on the caterpillar plot.
% 
% INSTANCEINDICES = PLOTINTERVALS(...)
%   if requested, the indices of the parameters, in the order they appear
%   on the plot, will be returned.  if possible, this will be returned as 
%   a matrix.  otherwise, it will be returned as a cell. 
% 
% 
% to customize the plot, optional inputs may be given as name-value pairs:
% PLOTINTERVALS(SAMPLES,PARAMETERREQUEST,'name1',VALUE1,'name1',VALUE2,...)
% pairs may be given in any order.  property names are case insensitive.
%   
%   'sortBy'
%       SORTBY changes how the function orders the parameter instances
%       along the Y-axis. 
%         'name'    >>  sort by name
%         'value'   >>  sort by value (of the point estimate)
%         [vector]  >>  applies the given custom ordering
%       NOTE: if SORTBY is a vector, it must contain only positive integers.
%   
%   'linecolor'
%       LINECOLOR overrides the default caterpillar colors (all black). 
%       LINECOLOR must be a 1x3 or Nx3 matrix of RGB-01 colors (where N is
%       the number of parameter instances).  if LINECOLOR is 1x3, then the
%       same color is used for all parameter instances. if LINECOLOR is Nx3
%       then each row is used for each successive parameter instance.
%   
%   'criticalValue'
%       CRITICALVALUE must be a scalar, numerical value.  
%       supplying CRITICALVALUE triggers the overlay of a vertical line at 
%       the given value.  this also triggers the function to color code
%       each line and marker such that parameter instances with a 95%
%       credible interval that does NOT include CRITICALVALUE are plotted
%       in black, and parameters with intervals that include the
%       CRITICALVALUE are plotted in gray (or a grayed-out LINECOLOR). 
%   
%   'truevalues'
%       TRUEVALUES is a strucutre of true values (assuming the model was
%       fit to simulated data). in TRUEVALUES, each field is a parameter
%       name, and each field's value is a numeric scalar or array of
%       values, where the dimensions match the parameter's size (array +
%       dimensions). 
%       if given, then a star marker will be added at the bottom of each
%       density at the true value for that [instance of the] parameter.   
%   
%   'truecolor'
%       optionally, override the default true value marker color scheme
%       (all black) with the color(s) given in TRUECOLOR.  
%       the size and usage demands are the same as for LINECOLOR. 
%       this property is only permissible if a 'truevalues' property-value
%       pair is also given. 
%   
%   'ygrid'
%       YGRID indicates whether to include a soft horizontal line across
%       the plot under each parameter's intervals.
%       the default value for YGRID is 'off'.
%   
%   'outer'
%       OUTER changes the bounds of the long, thin line, by specifying a
%       different % credible interval for it to present.  as such, OUTER
%       must be between  0 and 1. if SHADING is 0, then no thin line is
%       included. 
%       the default value for OUTER is 0.95 (for a 95% central CI).
%   
%   'inner'
%       INNER changes the bounds of the shorter, thick line, by specifying
%       a different % credible interval for it to present.  as such, INNER
%       must be between  0 and 1. if INNER is 0, then no thick line is
%       included. 
%       the default value for INNER is 0.50 (for a 50% central CI).
%   
%   'CImethod'
%       CIMETHOD changes how both different % credible intervals are
%       computed. 
%       valid CIMETHOD strings include:
%           'central'   >>  central (i.e., equal-quantile-tailed) interval
%           'HDI'       >>  highest density interval (HDI) [continuous]
%       the default value is 'central'.
% 
% 
% See also VIOLINDENSITY, HORZDENSITY, PLOTRECOVERY, EXTRACTSAMPLES
% 
% (c) beth baribault 2021 ---                                 > matstanlib 

msl.options

%% parse required inputs
if nargin < 2
    error('too few inputs.')
end

continuePlot = false;
if isequal('continue',samples)
    continuePlot = true;
    samples = parameterRequest;
    if isempty(varargin)
        error('at least two inputs are required.')
    elseif length(varargin)>=1
        parameterRequest = varargin{1};
        varargin(1) = [];
    end
end 

%samples
if ~isstruct(samples)
    error('the first input must be a structure of mcmc samples.')
end

%parameterRequest
gaveInstances = false;
if isempty(parameterRequest)
    error('the second input must be a parameter name string.')
elseif ischar(parameterRequest)
    %single parameter name given
elseif iscell(parameterRequest) && all(cellfun(@ischar,parameterRequest))
    %parameter instances given
    %(or multiple parameter names given)
    gaveInstances = true;
elseif ~ischar(parameterRequest) || isempty(parameterRequest)
    error('the second input must be a parameter name string.')
end

%% parse optional inputs
%ensure all remaining inputs are consistent with name-value pair format
if mod(length(varargin),2) > 0 || ...
        ~all(cellfun(@ischar,varargin(1:2:length(varargin))))
    error(['all inputs (after samples and parameterRequest) ' ...
        'must be submitted as name-value pairs.'])
elseif length(unique(varargin(1:2:length(varargin))))<length(varargin(1:2:length(varargin)))
    error('at least one property name (in the name-value pair inputs) is a duplicate.')
end

%set default values for the optional inputs
lineColor = NaN;   %use default colors
criticalValue = NaN;
trueValues = NaN;               addTrueValues = false;
trueColor = NaN;    %use default colors
sortBy = 'name';                validSortByStrings = {'name','value'};
ygridOnOff = 'off';             validYgridOnOff = {'on','off'};
outer = 0.95;
inner = 0.5;
CImethod = 'central';           validCIMethods = {'central','hdi'};

varargin(1:2:length(varargin)) = ... %case insensitive (convert all to lower case)
    cellfun(@lower,varargin(1:2:length(varargin)),'uni',0);
for v = 1:2:length(varargin)
    switch varargin{v}
        %----------------------------------------------------------------%
        case 'linecolor'
            lineColor = varargin{v+1};
            if isscalar(lineColor) && (isnan(lineColor) || isempty(lineColor))
                %do nothing --- will use default colors
            elseif isnumeric(lineColor)
                if ~ismatrix(lineColor) || size(lineColor,2)~=3 
                    error(['linecolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(lineColor)))
                elseif ~(all(lineColor(:) >= 0) && all(lineColor(:) <= 1))
                    error(['each row of linecolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('linecolor must be numeric.')
            end
        %----------------------------------------------------------------%
        case 'criticalvalue'
            criticalValue = varargin{v+1};
            if ~isnumeric(criticalValue) || ~isscalar(criticalValue)
                error('criticalvalue must be a single number.')
            end
        %----------------------------------------------------------------%
        case 'truevalues'
            trueValues = varargin{v+1};
            if ~isstruct(trueValues) || ~all(structfun(@isnumeric,trueValues))
                error(['trueValues must be structure where each field ' ...
                    'is a parameter name, and each field''s value is ' ...
                    'a numeric scalar or array of true values, where ' ...
                    'the dimensions match the parameter''s array + dimensions.'])
            end
            addTrueValues = true;
        %----------------------------------------------------------------%
        case 'truecolor'
            trueColor = varargin{v+1};
            if isscalar(trueColor) && (isnan(trueColor) || isempty(trueColor))
                %do nothing --- will use default color
            elseif ~ismatrix(trueColor) || size(trueColor,2)~=3 
                error(['truecolor must be a matrix with three columns, ' ...
                    'but the size given was %s.'],mat2str(size(trueColor)))
            elseif isnumeric(trueColor)
                if ~ismatrix(trueColor) || size(trueColor,2)~=3 
                    error(['truecolor must be a matrix with three columns, ' ...
                        'but the size given was %s.'],mat2str(size(trueColor)))
                elseif ~all(trueColor(:)<=1) || ~all(trueColor(:)>=0) 
                    error(['each row of truecolor must be a valid RGB-01 ' ...
                        'but values were given outside the [0 1] range.'])
                end
            else
                error('truecolor must be numeric.')
            end
%         %----------------------------------------------------------------%
%         case 'subset'
%             subset = varargin{v+1};
%             if isnumeric(subset) && ~isscalar(subset) && isvector(subset)
%                 if ~(all(mod(subset,1)==0) && all(subset>0))
%                     error('subset can only include positive integers.')
%                 end
%             else
%                 error('subset must be a numeric vector.')
%             end
        %----------------------------------------------------------------%
        case 'sortby'
            sortBy = varargin{v+1};
            if isnumeric(sortBy) && ~isscalar(sortBy) && iscolumn(sortBy)
                if all(mod(sortBy,1)==0) && all(sortBy>0)
                    sortOrder = sortBy;
                    sortBy = 'custom';
                else
                    error(['if sortby is a sorting order, ' ...
                        'it can only include positive integers.'])
                end
            elseif ~ischar(sortBy)
                error('sortby must be a string (@ischar==true).')
            elseif ~ismember(sortBy,validSortByStrings)
                error(['sortby input is not valid. valid inputs ' ...
                    'include: ''%s''.'],strjoin(validSortByStrings,''', '''))
            end
        %----------------------------------------------------------------%
        case 'ygrid'
            ygridOnOff = varargin{v+1};
            if ~ischar(ygridOnOff)
                error('ygrid must be a string (@ischar==true).')
            elseif ~ismember(ygridOnOff,validYgridOnOff)
                error(['ygrid input is not valid. valid inputs include: ' ...
                    '''%s''.'],strjoin(validYgridOnOff,''', '''))
            end
        %----------------------------------------------------------------%
        case 'outer'
            outer = varargin{v+1};
            if ~isnumeric(outer) || ~isscalar(outer)
                error('outer must be a single number.')
            elseif outer < 0 || outer > 1
                error('outer must be a proportion [0,1].')
            end
        %----------------------------------------------------------------%
        case 'inner'
            inner = varargin{v+1};
            if ~isnumeric(inner) || ~isscalar(inner)
                error('inner must be a single number.')
            elseif inner < 0 || inner > 1
                error('inner must be a proportion [0,1].')
            end
        %----------------------------------------------------------------%
        case 'cimethod'
            CImethod = lower(varargin{v+1});
            if ~ischar(CImethod)
                error('CImethod must be a string (@ischar==true).')
            elseif ~ismember(CImethod,validCIMethods)
                error(['CImethod input is not valid. valid inputs ' ...
                    'include: ''%s''.'],strjoin(validCImethods,''', '''))
            end
        %----------------------------------------------------------------%
        otherwise
            error('the optional input name ''%s'' was not recognized.', ...
                varargin{v})
    end
end

if size(trueColor,2)==3 && ~addTrueValues
    error(['trueColor was given, but no structure of trueValues ' ...
        'to display in that color was given.'])
end

%% extract corresponding parameter instance names
%create a list of parameter instances
if gaveInstances
    instances = parameterRequest;
else
    instances = getparaminstances(parameterRequest, ...
        fieldnames(samples),struct2cell(structfun(@size,samples,'uni',0)));
end
nInstances = length(instances);

%% sort to establish order of parameters on y-axis
switch sortBy
    case 'name'
        %sort by instance name
        %%%already done by getparaminstances!
        %instances = sort(instances);
        sortOrder = 1:nInstances;
    case 'value'
        %sort by instance point estimate value
        pointEstimates = NaN(size(instances));
        for n = 1:nInstances
            [parameter,ind] = str2ind(instances{n});
            if isempty(ind)
                chains = samples.(parameter);
            else
                chains = samples.(parameter)(:,:,ind{:});
            end
            pointEstimates(n) = mean(chains(:));
        end
        [~,sortOrder] = sort(pointEstimates,'descend');
        instances = instances(sortOrder);
    case 'custom'
        %sort by user-specified order
        whos instances sortOrder
        instances = instances(sortOrder);
end

%% get some nice colors for plotting
defaultLineColor = getcolors('black');
defaultTrueColor = getcolors('black');

% ... line
if any(isnan(lineColor(:))) || isempty(lineColor)
    lineColors = repmat(defaultLineColor,[nInstances 1]);
else
    if size(lineColor,1)==1
        lineColors = repmat(lineColor,[nInstances 1]);
    elseif size(lineColor,1)==nInstances
        lineColors = lineColor;
    else
        error('lineColor has invalid number of rows.')
    end
end
% ... trueColor
if any(isnan(trueColor(:))) || isempty(trueColor)
    trueColors = repmat(defaultTrueColor,[nInstances 1]);
else
    if size(trueColor,1)==1
        trueColors = repmat(trueColor,[nInstances 1]);
    elseif size(trueColor,1)==nInstances
        trueColors = trueColor;
    else
        error('trueColor has invalid number of rows.')
    end
end

lineColors = lineColors(sortOrder,:);
trueColors = trueColors(sortOrder,:);

%% plot intervals
%start a figure ...
if ~continuePlot
    f = figure('color',[1 1 1]);
    fpos = f.Position;
    f.Position = [fpos(1:2) [520 90+25*(nInstances)]*figScaling];
end
%... and an axis
hold on
axis ij %plot top to bottom

%make caterpillar plot
[parameter,~] = str2ind(instances{1});
xl = mean(samples.(parameter)(:))*[1 1];
instanceIndices = cell(size(instances)); %returned
instanceIdxStr = cell(size(instances));  %used for plot
for n  = 1:nInstances
    [parameter,ind] = str2ind(instances{n});
    if isempty(ind)
        %scalar
        chains = samples.(parameter);
        instanceIdxStr{n} = parameter;
        if addTrueValues
            trueVal = trueValues.(parameter);
        end
    else
        %instance
        chains = samples.(parameter)(:,:,ind{:});
        instanceIndices{n} = cell2mat(ind);
%         instanceIdxStr{n} = mat2str(cell2mat(ind));
        instanceIdxStr{n} = ['[' strjoin(arrayfun(@(x) num2str(x),cell2mat(ind), ...
            'uni',0),',') ']' ];
        if addTrueValues
            if ~isfield(trueValues,parameter)
                error(['parameter ''%s'' was not a field in the ' ...
                    'given trueValues structure.'],parameter)
            end
            trueVal = trueValues.(parameter)(ind{:});
        end
    end
    chains = chains(:);
    %underlay true value marker (outline & fill)
    if addTrueValues
%         plot(tr*[1 1],[n n+scaleF],'-','color','k')
        plot(trueVal,n,'linewidth',linePt, ...
            'marker','p','markersize',markSz*0.75, ...
            'markerfacecolor',trueColors(n,:),'markeredgecolor',trueColors(n,:))
    end
    %thin (95%) credible interval line
    CI95 = computecredint(chains,outer,CImethod);
    if ~isnan(criticalValue)
        %critical value in credible interval
        if CI95(1) <= criticalValue && criticalValue <= CI95(2)
            instanceColor = (0.8*[1 1 1] + lineColors(n,:))/2; %greyed-out
        %critical value outside credible interval
        else
            instanceColor = lineColors(n,:);
        end
    else
        instanceColor = lineColors(n,:);
    end
    plot(CI95,n*[1 1],'linewidth',linePt*0.5,'color',instanceColor)
    %thick (50%) credible interval line
    CI50 = computecredint(chains,inner,CImethod);
    plot(CI50,n*[1 1],'linewidth',linePt*2,'color',instanceColor)
    %point estimate/mean marker
    plot(mean(chains),n,'o', ...
        'linewidth',linePt*2,'markersize',markSz*0.75, ...
        'markerfacecolor','w','markeredgecolor',instanceColor)
    %redraw true value marker (outline only)
    if addTrueValues
        plot(trueVal,n,'linewidth',linePt, ...
            'marker','p','markersize',markSz*0.75, ...
            'markerfacecolor','none','markeredgecolor',trueColors(n,:))
    end
    %keep track of min & max values for a nice x-axis later
    if CI95(1) < xl(1); xl(1) = CI95(1); end
    if CI95(2) > xl(2); xl(2) = CI95(2); end
end
%overlay a vertical line at the critical value
verticalLimits = [0.25 nInstances+0.75];
if ~isnan(criticalValue)
    line(criticalValue*[1 1],verticalLimits,'color','k','linestyle',':')
    %keep track of min & max values for a nice x-axis later
    if criticalValue < xl(1); xl(1) = criticalValue; end
    if criticalValue > xl(2); xl(2) = criticalValue; end
end
%format plot
set(gca,'xlim',[xl(1)-0.1*diff(xl) xl(2)+0.1*diff(xl)])
set(gca,'ylim',verticalLimits,'ytick',1:nInstances, ...
    'yticklabel',instanceIdxStr,'ticklabelinterpreter','none')
if ischar(parameterRequest)
    xlabel(parameterRequest,'interpreter','none')
end
set(gca,'fontsize',fontSz,'ygrid',ygridOnOff,'box','on')

if nargout >= 1
    try %convert to a matrix, if possible
        varargout{1} = cell2mat(instanceIndices);
    catch
        %return cell
        varargout{1} = instanceIndices; 
    end
end
if nargout == 2
    varargout{2} = sortOrder;
elseif nargout > 2
    error('too many outputs requested.')
end

end