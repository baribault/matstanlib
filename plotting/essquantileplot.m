function essquantileplot(samples,diagnostics,parameterRequest)
%ESSQUANTILEPLOT generates the "efficiency of quantile estimates" diagnostic ESS plot.
% 
% this function visualizes the "efficiency of quantile estimates" plot
% recommended by Vehtari et al. (2020), one of three new diagnostic plots
% based on effective sample size (ESS) estimates.
% 
% visualizing whether ESS is notably lower for some quantiles (e.g., much
% lower ESS for extreme quantiles), especially if those quantiles seem to
% correlate with divergent transitions or hitting max tree depth, can help
% identify what areas of the marginal posterior are driving low ESS.  
% 
% the dashed line represents the minimum ESS, 100*(number of chains).
% 
% rug plots in the gray area at the bottom of the plot (beneath the solid
% black line representing ESS = 0) mark the quantiles of samples where
% diagnostic quantities indicated problematic sampling.  
% the rug plot representing divergent transitions (if any) will be plotted
% in red, while the rug plot representing that the max treedepth was hit
% (if it was) will be plotted in orange.  
% (if neither diagnostic was problematic, no rug plot is included.)  
% 
% NOTE: a maximum of 25 figures may be generated in a single call, to
%       mitigate the risk of memory overload.  
% 
% 
% ESSQUANTILEPLOT(SAMPLES,DIAGNOSTICS,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of poserior samples, and
%   DIAGNOSTICS is the structure of Stan's diagnostic quantites.  
%   both are assumed to be in the format generated by extractsamples.m.  
%   
%   if PARAMETERREQUEST is a parameter name string, this function 
%   generates a figure with [all instances of] that parameter only.
%   if PARAMETERREQUEST is a cell of parameter name strings, this 
%   function generates a figure with [all instances of] each of those 
%   parameters.
%   PARAMETERREQUEST may include specific parameter instances, by 
%   including a valid index or indices in brackets after the parameter 
%   name (e.g., 'mu[3]','sigma[2,1]').  wildcards may also be used to 
%   select a subset of instances of a given parameter (e.g.,
%   'sigma[2,*]').
% 
% 
% Reference:  Vehtari, Gelman, Simpson, Carpenter, BÃ¼rkner (2020). 
%                   Rank-normalization, folding, and localization: An
%                   improved R^ for assessing convergence of MCMC.  ArXiv.
% 
% 
% See also COMPUTEESS, ESSPLOTS, PLOTMCSE, RANKPLOTS, TRACEDENSITY
% 
% (c) beth baribault 2021 ---                                 > matstanlib

msl.options

%% parse required inputs
if nargin < 3
    error('too few inputs.')
end

%samples
if ~isstruct(samples)
    error('first input must be a structure of posterior samples.')
else
    %extract size info immediately
    allFields = fieldnames(samples);
    [nIterations,nChains] = size(samples.(allFields{1}),[1 2]);
    nSamples = nIterations*nChains;
end

%diagnostics
if ~isstruct(diagnostics)
    error(['second input must be the diagnostics structure ' ...
        '(consisitent with the output of extractsamples.m).'])
else
    if ~all(isfield(diagnostics,{'divergent__','treedepth__'}))
        error(['second input must be the diagnostics structure, but the ' ...
            'structure given doesn''t have the ''divergent__'' and/or ' ...
            '''treedepth__'' fields.'])
    end
    %extract diagnostic fields immediately
    divergent = diagnostics.divergent__;
    treedepth = diagnostics.treedepth__;
end

%parameterRequest
if isempty(parameterRequest)
    parameterRequest = fieldnames(samples);
elseif ~(iscell(parameterRequest) && all(cellfun(@ischar,parameterRequest)))
    if ischar(parameterRequest)
        parameterRequest = {parameterRequest};
    else
        error(['parameterRequest must be a string or cell of strings ' ...
               'containing valid parameter or instance name strings.'])
    end
end

maxTD = 10; %default

%% prepare to generate plots
divergentColor = getcolors('red');
treedepthColor = getcolors('orange');

%maximum number of figures to generate
maxNfigures = 25;

%create a list of parameter instances
parameters = getparaminstances(parameterRequest, ...
    fieldnames(samples),struct2cell(structfun(@size,samples,'uni',0)));

%warn if over the figure limit
if length(parameters) > maxNfigures
    warning(['requested %i traceplots, but this function will only ' ...
        'generate up to %i traceplots in a single call (to protect ' ...
        'against memory overload and subsequent freezing). ' ...
        'try requesting fewer parameters/parameter instances.  ' ...
        'continuing to generate the first %i traceplots now ...'], ...
        length(parameters),maxNfigures,maxNfigures)
end

%prepare for diagnostic overlays
%convert treedepth to an indicator of hitting max tree depth
treedepth = treedepth==maxTD;
%which diagnostics to plot?
quantities = [1 2];
if ~any(divergent(:)), quantities(1) = 0; end
if ~any(treedepth(:)), quantities(2) = 0; end
quantities(quantities==0) = [];

%% make an "efficiency of quantile estimates" plot

%quantiles to plot
xQuantiles = linspace(0.5/nQuantiles,1-0.5/nQuantiles,nQuantiles);

isInstance = cellfun(@(x) any(x=='['),parameters);
for p = 1:min([length(parameters),maxNfigures])
    %account for parameters vs. parameter instances
    if isInstance(p)
        [parameter,ind] = str2ind(parameters{p});
        chains = samples.(parameter)(:,:,ind{:});
    else
        parameter = parameters{p};
        chains = samples.(parameter);
    end
    
    %start a figure ...
    dumf = figure(999); %dummy figure to protect sizing
    f = figure('color',[1 1 1]);
    fpos = f.Position;
    f.Position = [fpos(1:2) [500 380]*figScaling];
    close(dumf.Number); %close dummy figure
    hold on
    
    %%% underlay lines at ESS criteria
    plot([-1 2],nChains*100*[1 1],'k--')
    plot([-1 2],[0 0],'k-')
    
    %%% plot efficiency per iteration
    ESSbyQuantile = NaN([1 length(xQuantiles)]);
    for n = 1:length(xQuantiles)
        ESSbyQuantile(n) = computeess(chains,'quantile',xQuantiles(n));
    end
    plot(xQuantiles,ESSbyQuantile,'ko', ...
        'markerfacecolor','k','markersize',markSz*0.65);
    
    %%% rug plots (plot divergences, hit max treedepth) %%%
    yl = ylim; set(gca,'ylim',[0 max([nSamples yl(2)])])
    %expand the y-axis to fit the diagnostics
    xl = xlim;
    yl = ylim;
    barMarkerSz = markSz*0.75;
    rug_pos(1) = -0.0065*barMarkerSz*diff(yl);
    rug_pos(2) = -0.0165*barMarkerSz*diff(yl);
    rug_pos(3) = -0.0265*barMarkerSz*diff(yl);
    %underlay light gray
    fill([-1 2 2 -1],[0 0 -yl(2) -yl(2)],0.95*[1 1 1])
    %make one rugplot per diagnostic
    c = 0;
    for q = quantities
        if     q==1, dx = divergent; dxColor = divergentColor;
        elseif q==2, dx = treedepth; dxColor = treedepthColor;
        end
        %convert from chains to quantiles
        qEdges = 0:0.0001:1;
        qValues = quantile(chains(:),qEdges);
        inQtls = discretize(chains(find(dx)),[-inf qValues(2:end-1) inf]);
        %rug plot
        c = c + 1; %increment counter
        x_dx = qEdges(inQtls);
        y_dx = rug_pos(c)*ones(size(x_dx));
        plot(x_dx,y_dx,'|','markersize',barMarkerSz,'color',dxColor)
    end
    if c==0, c = 1; end
    %reestablish limits, just to be sure
    xlim(xl); ylim([sum(rug_pos(c:c+1).*[1 2])/3 yl(2)]);
    
    %%% format
    xlim([0 1])
    yt = get(gca,'ytick'); yt(yt<0) = []; set(gca,'ytick',yt)
    xlabel('quantile')
    ylabel('ESS for quantiles')
    title(parameters{p},'interpreter','none')
    set(gca,'fontsize',fontSz,'box','on')
end

end