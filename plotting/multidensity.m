function multidensity(samples,varargin)
%MULTIDENSITY creates a NxN matrix of plots of joint densities.
% 
% this function generates a single figure with NxN tiled subplots. 
% off the diagonal, bivariate densities are presented as contour plots.
% along the diagonal, univariate  densities are presented as smoothed
% densities.
% 
% NOTE: this function will only plot up to 10 parameters in a single 
% figure.
% 
% MULTIDENSITY(SAMPLES,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of poserior samples in the format 
%   generated by extractsamples.m.  
%   if PARAMETERREQUEST is a parameter name string, this function 
%   generates a figure with [all instances of] that parameter only.
%   if PARAMETERREQUEST is a cell of parameter name strings, this 
%   function generates a figure with [all instances of] each of those 
%   parameters.
%   PARAMETERREQUEST may include specific parameter instances, by 
%   including a valid index or indices in brackets after the parameter 
%   name (e.g., 'mu[3]','sigma[2,1]').  wildcards may also be used to 
%   select a subset of instances of a given parameter (e.g.,
%   'sigma[2,*]').
%   for a request that includes N parameter instances, a NxN plot of 
%   joint densities is created.
% 
% MULTIDENSITY(...,DIAGNOSTICS)
% MULTIDENSITY(...,DIAGNOSTICS,DIAGNOSTICREQUEST)  
%   if DIAGNOSTICS, the structure of diagnostic quantities (as generated by
%   extractsamples.m), is also given, then additional diagnostic plot
%   options will be available.  
%   these options can be selected with DIAGNOSTICREQUEST (given after
%   DIAGNOSTICS). valid DIAGNOSTICREQUEST options include:
%       'energy__'    >>  includes the NUTS sampler's energy diagnostic
%                           (diagnostics.energy__) on the plot as if it
%                           were another parameter (i.e., with its own
%                           row/column; but using gray contours).   
%       'divergent__' >>  samples derived from divergent transitions will
%                           be highlighted in red on the off-diagonal plots. 
%   if DIAGNOSTICREQUEST may be a string or cell of strings.  
%   if just DIAGNOSTICS is given, then DIAGNOSTICREQUEST is assigned a
%   default value of 'divergent'. 
% 
% 
% MULTIDENSITY(...,NAMESONDIAG)
%   optionally, NAMESONDIAG, a true/false/0/1 value, may also be given.  
%   if NAMESONDIAG is true, then parameter names will be overlaid on the
%   marginals along the diagonal.  
%   if NAMESONDIAG is true, then parameter names included along the
%   perimeter of the plot, as axis labels. 
%   by default, NAMESONDIAG is true.
% 
% 
% Example
%   > multidensity(samples,{'mu*','sigma','delta[3]'})
%   > multidensity(samples,{},diagnostics,'energy__')
% 
% 
% See also SMOOTHDENSITY, PLOTDENSITY, JOINTDENSITY, VIOLINDENSITY, 
%   EXTRACTSAMPLES
% 
% (c) beth baribault 2019 ---                                 > matstanlib 

msl.options

%% parse inputs

%samples
if nargin < 1 || ~isstruct(samples)
    error('the first input must be the samples structure.')
end

%parameterRequest
if isempty(varargin) || ...
        ~(isempty(varargin{1}) || ischar(varargin{1}) || iscell(varargin{1}))
    %if no parameterRequest given, request all parameter names
    parameterRequest = fieldnames(samples); %default
else
    %if parameterRequest given ...
    parameterRequest = varargin{1};
    %... pop it out of varargin ... 
    varargin = varargin(2:end);
    %... then parse:
    if isempty(parameterRequest)
        parameterRequest = fieldnames(samples); %default
    elseif ischar(parameterRequest)
        parameterRequest = {parameterRequest};
    elseif iscell(parameterRequest) 
        if ~all(cellfun(@ischar,parameterRequest))
            error(['parameterRequest must be input as a string or ' ...
                   'cell of strings.'])
        end
    end
end
        
%%% optional inputs %%%             %defaults
foundNamesOnDiag = false;           namesOnDiag = true;
foundDiagnostics = false;           addDiagnostics = false;
foundDiagnosticsRequest = false;    diagnosticRequest = {};
foundMaxTD = false;                 maxTD = 10;

for v = 1:length(varargin)
    %namesOnDiag
    if islogical(varargin{v}) || (isnumeric(varargin{v}) && ...
                    isscalar(varargin{v}) && ismember(varargin{v},[0 1]))
        if foundNamesOnDiag
            error('can only have one true/false input (namesOnDiag).')
        else
            namesOnDiag = varargin{v};
            foundNamesOnDiag = true;
        end
    %maxTD
    elseif isnumeric(varargin{v}) && isscalar(varargin{v}) && ...
            mod(varargin{v},1)>0 && varargin{v}>1
        if foundMaxTD
            error('can only have one integer input (maxTD).')
        else
            maxTD = varargin{v};
            foundMaxTD = true;
        end
    %addDiagnostics
    elseif isstruct(varargin{v})
        if foundDiagnostics
            error('can only have one optional struct-type input (diagnostics).')
        elseif ~isfield(varargin{v},'divergent__')
            error(['an optional struct-type input other than the ' ...
                'permitted diagnostics structure was given (i.e., the ' ...
                'optional struct-type input does not have the ' ...
                'expected fields (e.g., ''divergent__'').'])
        else
            addDiagnostics = true;
            diagnostics = varargin{v};
            foundDiagnostics = true;
        end
    %diagnosticsRequest
    elseif ischar(varargin{v}) || iscell(varargin{v}) && all(cellfun(@ischar,varargin{v}))
        if foundDiagnosticsRequest
            error(['can only have one optional string or ' ...
                'cell of string-type input (diagnosticRequest).'])
        else
            foundDiagnosticsRequest = true;
            if ischar(varargin{v})
                diagnosticRequest = varargin(v);
            else
                diagnosticRequest = varargin{v};
            end
        end
    else
        error('unrecognized optional input type.')
    end
end
clearvars varargin

%continue checking optional diagnostics inputs
%... nothing to add
if addDiagnostics && isempty(diagnosticRequest)
    addDiagnostics = false;
%... requested but no struct
elseif ~addDiagnostics && ~isempty(diagnosticRequest)
    error(['diagnostic options were requested (''%s''), but no' ...
        ' diagnostics structure was given.'], ...
        strjoin(diagnosticRequest,''', '''))
end
%... ensure suffix
noSuffix = cellfun(@(x) ~endsWith(x,'__'),diagnosticRequest);
diagnosticRequest(noSuffix) = ...
    cellfun(@(x) [x '__'],diagnosticRequest(noSuffix),'uni',0);
%... check dx available
validDiagnosticRequests = {'divergent__','treedepth__','energy__'};
if addDiagnostics
    isMissingDx = ~ismember(diagnosticRequest,fieldnames(diagnostics));
    if any(isMissingDx)
        error(['the following elements of diagnosticsRequest were ' ...
            'not fields in the diagnostics structure: ''%s'''], ...
            strjoin(diagnosticRequest(isMissingDx),''', '''))
    end
end
%... extract
addDivergent = false; addTreedepth = false; addEnergy = false;
if addDiagnostics && ismember('divergent__',diagnosticRequest)
    addDivergent = true;
    divergent = diagnostics.divergent__(:);
end
if addDiagnostics && ismember('treedepth__',diagnosticRequest)
    addTreedepth = true;
    treedepth = diagnostics.treedepth__(:);
    treedepth = treedepth==maxTD;
end
if addDiagnostics && ismember('energy__',diagnosticRequest)
    addEnergy = true;
    energy = diagnostics.energy__(:);
end

%% prepare to plot
%create a list of parameter instances
instances = getparaminstances(parameterRequest,fieldnames(samples), ...
                           struct2cell(structfun(@size,samples,'uni',0)));
isInstance = cellfun(@(x) any(x=='['),instances);

%do not try to plot more than 10 parameters
np = length(instances);
if np < 2
    error(['at least two parameter instances are required. ' ...
        'try requesting more parameters/parameter instances.'])
end
if np > 10
    error(['multidensity will not include more than 10 parameter ' ...
        'instances in a single figure. try requesting fewer parameters/' ...
        'parameter instances.'])
end
if addEnergy
    np = np+1;
    instances{end+1} = 'energy__';
    isInstance(end+1) = 0;
end

biplotType = 'contour'; %be VERY cautious in changing this

%number of levels for the contour plots
nLevels = 6;

%x-axis tick label rotation
xTickAngle = 90; %45;

%select colors for plots
% ... marker color for divergent transitions
divergentColor = getcolors('red','darkred','blend');
% ... marker color for hitting max treedepth
treedepthColor = getcolors('orange');
% ... colormap for contour layer (lowest to hightest density)
sampleColorMin0 = getcolors('lightslate','lightgray','gray','blend');
sampleColor = getcolors('darkblue');
energyColorMin0 = getcolors('lightgray');
energyColor = getcolors('darkgray');

sampleColorMin  = sampleColorMin0/max(sampleColorMin0);
sampleColorMinX = 0.9*sampleColorMin;
energyColorMin  = energyColorMin0/max(energyColorMin0);
energyColorMinX = 0.9*energyColorMin;

switch biplotType
    case 'ksdensity'
        sampleCmap = makecolormap(sampleColorMin,sampleColor,128);
        energyCmap = makecolormap(energyColorMin,energyColor,128);
    case 'contour'
        sampleCmap = makecolormap(sampleColorMinX,sampleColor,nLevels);
        energyCmap = makecolormap(energyColorMinX,energyColor,nLevels);
    case 'scatter'
        %%%0.925*[1 1 1]
end

%%
% % % %test discrete
% % % instances{1} = 'discrete';  isInstance(1) = 0;
% % % samples.discrete = binornd(10,0.2, ...
% % %     size(samples.(str2ind(instances{end})),[1 2]));

%% make NxN multidensity plot
%start a figure ...
dumf = figure(999); %dummy figure to protect sizing
fh = figure('color',[1 1 1]);
fpos = fh.Position;
fh.Position = [fpos(1:2) [125+125*np 75+125*np]*figScaling];
close(dumf.Number) %close dummy figure
%... and NxN axes
tiledlayout(np,np,'tilespacing','none')%,'tileindexing','columnmajor') %only in 2021a+

%on diagonal: univariate marginal posterior density
for n = 1:(np*np)
    %determine this axis' position within the grid of axes
    [row,col] = ind2sub([np np],n); %via *column major* indexing
    onDiagonal = row==col;    offDiagonal = ~onDiagonal;
    %select an axis
    ind = sub2ind([np np],col,row); %nexttile uses *row major* indexing
    nexttile(ind); hold on
    %format this axis
    set(gca,'box','on','fontsize',fontSz)
    
    %move X/Y axis to the top/right for the topmost/rightmost column of plots
    if row==1  || row<col, set(gca,'XAxisLocation','top'); end
    if col==np || row<col, set(gca,'YAxisLocation','right'); end
    
    %labels & ticks for the ... x-axis
    if namesOnDiag
        %if off diag, include rotated tick labels; otherwise no tick labels
        if row==col || ~(row==1 || row==np)
            set(gca,'xticklabels',{})
        else
            set(gca,'XTickLabelRotation',xTickAngle)
        end
    else
        %if first row, add parameter name labels
        if row==1
            xlabel(instances{col},'interpreter','none','fontweight','bold')
        end
        %if last row, include rotated tick labels; otherwise no tick labels
        if row < np
            set(gca,'xticklabels',{})
        else
            set(gca,'XTickLabelRotation',xTickAngle)
        end
    end
    %labels & ticks for the ... y-axis
    if namesOnDiag
        %if off diag, include tick labels; otherwise no tick labels
        if row==col || ~(col==1 || col==np)
            set(gca,'yticklabels',{})
        end
    else
        %if first column, add parameter name labels
        %iff last column, include tick labels
        %*UNLESS* it is also the last row --- then flip!
        if (col==1 && row<np) || (col==np && row==np)
            ylabel(instances{row},'interpreter','none','fontweight','bold')
        end
        if ~((col==np && row<np) || (col==1 && row==np))
            set(gca,'yticklabels',{})
        end
    end
    
    %extract samples, while accounting for parameters vs. parameter instances
    %... col determines the X axis
    if addEnergy && col==np, chains_xc = diagnostics.energy__;
    else %select chains
        if isInstance(col)
            [parameter,ind] = str2ind(instances{col});
            chains_xc = samples.(parameter)(:,:,ind{:});
        else
            parameter = instances{col};
            chains_xc = samples.(parameter);
        end
    end
    chains_xc = chains_xc(:);
    xl = [min(chains_xc) max(chains_xc)];
    %... row determines the Y axis
    if offDiagonal
        if addEnergy && row==np, chains_yr = diagnostics.energy__;
        else %select chains
            if isInstance(row)
                [parameter,ind] = str2ind(instances{row});
                chains_yr = samples.(parameter)(:,:,ind{:});
            else
                parameter = instances{row};
                chains_yr = samples.(parameter);
            end
        end
        chains_yr = chains_yr(:);
        yl = [min(chains_yr) max(chains_yr)];
    end
    
    %if on diagonal, univariate marginal posterior density (or names) ...
    if onDiagonal
        if addEnergy && row==np
            marginalFaceColor = 'none';
            marginalEdgeColor = energyColor;
        else
            marginalFaceColor = 'none';
            marginalEdgeColor = sampleColor;
        end
        marginalEdgeColor = mean([marginalEdgeColor;1 1 1]);
        %underlay smoothed density
        isDiscrete = all(~mod(chains_xc,1));
        [f,x] = smoothdensity(chains_xc);
        if isDiscrete
            %discrete plot
            bar(x,f,'linewidth',linePt, ...
                'facecolor',marginalFaceColor,'edgecolor',marginalEdgeColor)
        else
            %continuous plot
            area(x,f,'linewidth',linePt, ...
                'facecolor',marginalFaceColor,'edgecolor',marginalEdgeColor)
        end
        xlim(xl)
        set(gca,'ytick',[])
        %overlay parameter instance name
        if namesOnDiag
            %... and names
            %(if name is long, will extend beyond plot!)
            text(mean(xlim),mean(ylim),instances{row}, ...
                'interpreter','none', ...
                'fontsize',fontSz,'fontweight','bold', ...
                'horizontalalignment','center','verticalalignment','middle')
        end
    end
    
    %set colormap for contour plots
    if addEnergy && ismember(np,[row col])
        colormap(gca,energyCmap)
        scMarkColor = energyColor;
    else
        colormap(gca,sampleCmap)
        scMarkColor = sampleColor;
    end
    
    %if off diagonal, bivariate marginal posterior density ...
    if offDiagonal
        %contour plot
        switch biplotType
          %--------------------------------------------------------------%
          case 'ksdensity'
            %%% bivariate smoothed density estimate %%%
            ksdensity(gca,[chains_xc,chains_yr],'PlotFcn','contour')
          %--------------------------------------------------------------%
          case 'contour'
            %%% bivariate histogram %%%
            [Fgrid,Xedges,Yedges] = histcounts2(chains_xc,chains_yr, ...
                'normalization','pdf'); %(actually scaling is optional)
            Fgrid = Fgrid';
            %midpoints of bins
            Xmids = (Xedges(1:end-1) + Xedges(2:end))/2;
            Ymids = (Yedges(1:end-1) + Yedges(2:end))/2; 
            %... meshgrid
            [Xgrid,Ygrid] = meshgrid(Xmids,Ymids);
            maxF = max(Fgrid(:));
            minF = mink(unique(Fgrid(:)),2);
            if minF(1)>0, minF = minF(1); else minF = minF(2); end
            %contour plot where the outermost line/fill includes ALL samples
            %VERSION 1: outline
            % levels = linspace(eps,maxF,nLevels+1); %eps => exclude Fgrid bins with 0 samples
            levels = linspace(minF,maxF,nLevels+1); %exclude Fgrid bins with 0 samples
            contourf(Xgrid,Ygrid,Fgrid, ...
                'levellist',levels,'fill','on','linecolor','flat') %%%filled
            % contour(Xgrid,Ygrid,Fgrid,'levellist',levels,'linecolor','k') %%%just outlines
          %--------------------------------------------------------------%
          case 'scatter'
            %scatter plot
            %(MUCH SLOWER AND HUUUUGE MEMORY DRAIN!!!)
            scatter(chains_xc,chains_yr, ...
                    'sizedata',markSz, ...
                    'markerfacecolor',scMarkColor, ...
                    'markeredgecolor',scMarkColor, ...
                    'markerfacealpha',0.5,'markeredgealpha',0.5)
        end
        %overlay divergent transitions
        if addDivergent
            plot(chains_xc(divergent==1),chains_yr(divergent==1), ...
                'linestyle','none','linewidth',linePt*0.5, ...
                'markerfacecolor','none','markeredgecolor',divergentColor, ...
                'marker','x','markersize',markSz*0.5)
%                 'marker','.','markersize',markSz*0.8)
%                 'marker','o','markersize',markSz*0.35)
        end
        %overlay max treedepth
        if addTreedepth
            plot(chains_xc(treedepth==1),chains_yr(treedepth==1), ...
                'linestyle','none','linewidth',linePt*0.5, ...
                'markerfacecolor',treedepthColor,'markeredgecolor',treedepthColor, ...
                'marker','.','markersize',markSz*0.8)
%                 'marker','x','markersize',markSz*0.5)
%                 'marker','o','markersize',markSz*0.35)
        end
        xlim(xl)
        ylim(yl)
    end
    
    %add a colorbar (one plot only!)
    if row==np && col==np
        %add a colorbar
        cb = colorbar;
        cb.Ticks = [];
        % sz = 1/(np+1);
        % cb.Position = [sz*(np+0.5)+cb.Position(3)*1.5   sz/2  ...
        %                cb.Position(3)*1.5               cb.Position(4)];
    end
end

end