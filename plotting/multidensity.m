function multidensity(samples,varargin)
%MULTIDENSITY creates a NxN matrix of plots of joint densities.
% 
% this function generates a single figure with NxN tiled subplots. 
% off the diagonal, bivariate densities are presented as contour plots.
% along the diagonal, univariate  densities are presented as smoothed
% densities.
% 
% MULTIDENSITY(SAMPLES,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of poserior samples in the format 
%   generated by extractsamples.m.  
%   if PARAMETERREQUEST is a parameter name string, this function 
%   generates a figure with [all instances of] that parameter only.
%   if PARAMETERREQUEST is a cell of parameter name strings, this 
%   function generates a figure with [all instances of] each of those 
%   parameters.
%   PARAMETERREQUEST may include specific parameter instances, by 
%   including a valid index or indices in brackets after the parameter 
%   name (e.g., 'mu[3]','sigma[2,1]').  wildcards may also be used to 
%   select a subset of instances of a given parameter (e.g.,
%   'sigma[2,*]').
%   for a request that includes N parameter instances, a NxN plot of 
%   joint densities is created.
% 
% NOTE: this function will only plot up to 10 parameters in a single 
% figure.
% 
% MULTIDENSITY(...,DIAGNOSTICS)
% MULTIDENSITY(...,DIVERGENT)
%   optionally, samples derived from divergent transitions may be 
%   highlighted in red on the off-diagonal plots.  
%   either submit a DIAGNOSTICS structure directly, or submit a 
%   [nIterations nChains]-sized matrix of indicators of divergent 
%   transitions.
% 
% 
% Example
%   > multidensity(samples,{'mu','sigma','delta'})
% 
% 
% See also SMOOTHDENSITY, PLOTDENSITY, JOINTDENSITY, VIOLINDENSITY, 
%   EXTRACTSAMPLES
% 
% (c) beth baribault 2019 ---                                 > matstanlib 

msl.options

%% parse inputs

%samples
if nargin < 1 || ~isstruct(samples)
    error('the first input must be the samples structure.')
end

%%% optional inputs %%%
parameterRequest = fieldnames(samples); %default
overlayDivergent = false;               %default
namesOnDiag = true;                     %default

for v = 1:length(varargin)
    %namesOnDiag
    if islogical(varargin{v})
        namesOnDiag = varargin{v};
    elseif isnumeric(varargin{v}) && isscalar(varargin{v}) && ismember(varargin{v},[0 1])
        namesOnDiag = varargin{v};
    %overlayDivergent
    elseif isnumeric(varargin{v}) && ismatrix(varargin{v}) && all(ismember(varargin{v}(:),[0 1]))
        %matrix of divergent indicators already extracted
        divergent = varargin{v};
        overlayDivergent = true;
    elseif isstruct(varargin{v}) && isfield(varargin{v},'divergent__')
        %diagnostic structure --- need to extract divergent__ field
        divergent = varargin{v}.divergent__;
        overlayDivergent = true;
    %parameterRequest
    elseif ischar(varargin{v})
        %convert parameter name string to cell of string
        parameterRequest = {varargin{v}};
    elseif iscell(varargin{v}) && all(cellfun(@ischar,varargin{v}))
        parameterRequest = varargin{v};
    else
        error('unrecognized optional input type.')
    end
end
clearvars varargin

if nargin > 4
    error('too many inputs.')
end

%% prepare to plot
%create a list of parameter instances
instances = getparaminstances(parameterRequest,fieldnames(samples), ...
                           struct2cell(structfun(@size,samples,'uni',0)));
isInstance = cellfun(@(x) any(x=='['),instances);

%do not try to plot more than 10 parameters
np = length(instances);
if np < 2
    error(['at least two parameter instances are required. ' ...
        'try requesting more parameters/parameter instances.'])
end
if np > 10
    error(['multidensity will not include more than 10 parameter ' ...
        'instances in a single figure. try requesting fewer parameters/' ...
        'parameter instances.'])
end

biplotType = 'contour'; %be VERY cautious in changing this

%number of levels for the contour plots
nLevels = 6;

%x-axis tick label rotation
xTickAngle = 90; %45;

%select colors
% ... [on diagonal] smoothed univariate density
if namesOnDiag
    marginalFcolor = 'none';
    marginalEcolor = getcolors('lightgray');%0.675*[1 1 1];
else %marginalOnDiag
    marginalFcolor = 'none';
    marginalEcolor = getcolors('darkgray');%[0 0 0];
end
% ... [off diagonal] marker color for divergent transitions
divergentColor = getcolors('red');
% ... [off diagonal] colormap for contour layer (lowest to hightest density)
lowProbColor = getcolors('lightgray','white','blend');
highProbColor = 'darkblue';
switch biplotType
    case 'ksdensity'
        cmap = makecolormap(lowProbColor,highProbColor,128);
    case 'contour'
        cmap = makecolormap(0.925*[1 1 1],highProbColor,nLevels);
end

%%
% % % %test discrete
% % % instances{1} = 'discrete';  isInstance(1) = 0;
% % % samples.discrete = binornd(10,0.2, ...
% % %     size(samples.(str2ind(instances{end})),[1 2]));

%% make NxN multidensity plot
%start a figure ...
dumf = figure(999); %dummy figure to protect sizing
fh = figure('color',[1 1 1]);
fpos = fh.Position;
fh.Position = [fpos(1:2) [125+125*np 75+125*np]*figScaling];
close(dumf.Number) %close dummy figure
%... and NxN axes
tiledlayout(np,np,'tilespacing','none')%,'tileindexing','columnmajor') %only in 2021a+

%on diagonal: univariate marginal posterior density
for n = 1:(np*np)
    %determine this axis' position within the grid of axes
    [row,col] = ind2sub([np np],n); %via *column major* indexing
    onDiagonal = row==col;    offDiagonal = ~onDiagonal;
    %select an axis
    ind = sub2ind([np np],col,row); %nexttile uses *row major* indexing
    nexttile(ind); hold on
    %format this axis
    set(gca,'box','on','fontsize',fontSz)
    
    %move X/Y axis to the top/right for the topmost/rightmost column of plots
    if row==1  || row<col, set(gca,'XAxisLocation','top'); end
    if col==np || row<col, set(gca,'YAxisLocation','right'); end
    
    %labels & ticks for the ... x-axis
    if namesOnDiag
        %if off diag, include rotated tick labels; otherwise no tick labels
        if row==col || ~(row==1 || row==np)
            set(gca,'xticklabels',{})
        else
            set(gca,'XTickLabelRotation',xTickAngle)
        end
    else
        %if first row, add parameter name labels
        if row==1
            xlabel(instances{col},'interpreter','none','fontweight','bold')
        end
        %if last row, include rotated tick labels; otherwise no tick labels
        if row < np
            set(gca,'xticklabels',{})
        else
            set(gca,'XTickLabelRotation',xTickAngle)
        end
    end
    %labels & ticks for the ... y-axis
    if namesOnDiag
        %if off diag, include tick labels; otherwise no tick labels
        if row==col || ~(col==1 || col==np)
            set(gca,'yticklabels',{})
        end
    else
        %if first column, add parameter name labels
        %iff last column, include tick labels
        %*UNLESS* it is also the last row --- then flip!
        if (col==1 && row<np) || (col==np && row==np)
            ylabel(instances{row},'interpreter','none','fontweight','bold')
        end
        if ~((col==np && row<np) || (col==1 && row==np))
            set(gca,'yticklabels',{})
        end
    end
    
    %extract samples, while accounting for parameters vs. parameter instances
    %... col determines the X axis
    if isInstance(col)
        [parameter,ind] = str2ind(instances{col});
        chains_xc = samples.(parameter)(:,:,ind{:});
    else
        parameter = instances{col};
        chains_xc = samples.(parameter);
    end
    chains_xc = chains_xc(:);
    xl = [min(chains_xc) max(chains_xc)];
    %... row determines the Y axis
    if offDiagonal
        if isInstance(row)
            [parameter,ind] = str2ind(instances{row});
            chains_yr = samples.(parameter)(:,:,ind{:});
        else
            parameter = instances{row};
            chains_yr = samples.(parameter);
        end
        chains_yr = chains_yr(:);
        yl = [min(chains_yr) max(chains_yr)];
    end
    
    %if on diagonal, univariate marginal posterior density (or names) ...
    if onDiagonal
        %underlay smoothed density
        isDiscrete = all(~mod(chains_xc,1));
        [f,x] = smoothdensity(chains_xc);
        if isDiscrete
            %discrete plot
            bar(x,f,'linewidth',linePt, ...
                'facecolor',marginalFcolor,'edgecolor',marginalEcolor)
        else
            %continuous plot
            area(x,f,'linewidth',linePt, ...
                'facecolor',marginalFcolor,'edgecolor',marginalEcolor)
        end
        xlim(xl)
        set(gca,'ytick',[])
        %overlay parameter instance name
        if namesOnDiag
            %... and names
            %(if name is long, will extend beyond plot!)
            text(mean(xlim),mean(ylim),instances{row}, ...
                'interpreter','none', ...
                'fontsize',fontSz,'fontweight','bold', ...
                'horizontalalignment','center','verticalalignment','middle')
        end
    end
    
    %set colormap for contour plots
    colormap(cmap)
    
    %if off diagonal, bivariate marginal posterior density ...
    if offDiagonal
        %contour plot
        switch biplotType
          case 'ksdensity'
            %%% bivariate smoothed density estimate %%%
            ksdensity(gca,[chains_xc,chains_yr],'PlotFcn','contour')
          case 'contour'
            %%% bivariate histogram %%%
            [Fgrid,Xedges,Yedges] = histcounts2(chains_xc,chains_yr, ...
                'normalization','pdf'); %(actually scaling is optional)
            Fgrid = Fgrid';
            %midpoints of bins
            Xmids = (Xedges(1:end-1) + Xedges(2:end))/2;
            Ymids = (Yedges(1:end-1) + Yedges(2:end))/2; 
            %... meshgrid
            [Xgrid,Ygrid] = meshgrid(Xmids,Ymids);
            maxF = max(Fgrid(:));
            minF = mink(unique(Fgrid(:)),2);
            if minF(1)>0, minF = minF(1); else minF = minF(2); end
            %contour plot where the outermost line/fill includes ALL samples
            %VERSION 1: outline
            % levels = linspace(eps,maxF,nLevels+1); %eps => exclude Fgrid bins with 0 samples
            levels = linspace(minF,maxF,nLevels+1); %exclude Fgrid bins with 0 samples
            contourf(Xgrid,Ygrid,Fgrid, ...
                'levellist',levels,'fill','on','linecolor','flat') %%%filled
            % contour(Xgrid,Ygrid,Fgrid,'levellist',levels,'linecolor','k') %%%just outlines
          case 'scatter'
            %scatter plot
            %(MUCH SLOWER AND HUUUUGE MEMORY DRAIN!!!)
            scatter(chains_xc,chains_yr, ...
                    'sizedata',markSz, ...
                    'markerfacecolor',markerFcolor, ...
                    'markeredgecolor',markerEcolor, ...
                    'markerfacealpha',0.5,'markeredgealpha',0.5)
        end
        %overlay divergent transitions
        if overlayDivergent
            plot(chains_xc(divergent==1),chains_yr(divergent==1), ...
                'linestyle','none','linewidth',linePt*0.5, ...
                'markerfacecolor','none','markeredgecolor',divergentColor, ...
                'marker','.','markersize',markSz*0.8)
%                 'marker','o','markersize',markSz*0.35)
%                 'marker','x','markersize',markSz*0.5)
        end
        xlim(xl)
        ylim(yl)
    end
    
    %add a colorbar (one plot only!)
    if row==np && col==np
        %add a colorbar
        cb = colorbar;
        cb.Ticks = [];
        % sz = 1/(np+1);
        % cb.Position = [sz*(np+0.5)+cb.Position(3)*1.5   sz/2  ...
        %                cb.Position(3)*1.5               cb.Position(4)];
    end
end

end