function multidensity(samples,parameterRequest,varargin)
%MULTIDENSITY creates a NxN matrix of plots of joint densities.
% 
% this function generates a single figure with NxN tiled subplots. 
% off the diagonal, bivariate densities are presented as contour plots.
% along the diagonal, univariate  densities are presented as smoothed
% densities.
% 
% MULTIDENSITY(SAMPLES,PARAMETERREQUEST)
%   SAMPLES is assumed to be a strucutre of poserior samples in the format 
%   generated by extractsamples.m.  
%   if PARAMETERREQUEST is a parameter name string, this function 
%   generates a figure with [all instances of] that parameter only.
%   if PARAMETERREQUEST is a cell of parameter name strings, this 
%   function generates a figure with [all instances of] each of those 
%   parameters.
%   PARAMETERREQUEST may include specific parameter instances, by 
%   including a valid index or indices in brackets after the parameter 
%   name (e.g., 'mu[3]','sigma[2,1]').  wildcards may also be used to 
%   select a subset of instances of a given parameter (e.g.,
%   'sigma[2,*]').
%   for a request that includes N parameter instances, a NxN plot of 
%   joint densities is created.
% 
% NOTE: this function will only plot up to 10 parameters in a single 
% figure.
% 
% MULTIDENSITY(...,DIAGNOSTICS)
% MULTIDENSITY(...,DIVERGENT)
%   optionally, samples derived from divergent transitions may be 
%   highlighted in red on the off-diagonal plots.  
%   either submit a DIAGNOSTICS structure directly, or submit a 
%   [nIterations nChains]-sized matrix of indicators of divergent 
%   transitions.
% 
% Example
%   MULTIDENSITY(samples,{'mu','sigma','delta'})
% 
% See also SMOOTHDENSITY, PLOTDENSITY, JOINTDENSITY, VIOLINDENSITY, 
%   EXTRACTSAMPLES
% 
% (c) beth baribault 2019 ---                                 > matstanlib 

matstanlib_options

%% check inputs

%samples
if ~isstruct(samples)
    error('the first input must be the samples structure.')
end

%parameterRequest
if nargin < 2
    %default is all parameters
    parameterRequest = fieldnames(samples);
end
if ischar(parameterRequest)
    %convert string to cell of strings
    parameterRequest = {parameterRequest};
end
if ~iscell(parameterRequest) || ~all(cellfun(@ischar,parameterRequest))
    error(['the parameterRequest input must be a parameter name ' ...
           'string or cell of strings.'])
end

%diagnostics/divergent
overlayDivergent = false;
if nargin > 2
    %highlight divergent transitions
    if isstruct(varargin{1}) && isfield(varargin{1},'divergent__')
        %diagnostic structure --- need to extract divergent__ field
        divergent = varargin{1}.divergent__;
    elseif isnumeric(varargin{1}) && ...
            ismatrix(varargin{1}) && all(ismember(varargin{1},[0 1]))
        %matrix of divergent indicators already extracted
        divergent = varargin{1};
    else
        error(['the optional input must be either the diagnostics ' ...
            'structure or a matrix of divergent transition indicators.'])
    end
    divergent = divergent(:);
    if any(divergent==1)
        overlayDivergent = true;
    end
end


if nargin > 3
    error('too many inputs.')
end

%% prepare to plot
%create a list of parameter instances
instances = getparaminstances(parameterRequest,fieldnames(samples), ...
                           struct2cell(structfun(@size,samples,'uni',0)));
isInstance = cellfun(@(x) any(x=='['),instances);

%do not try to plot more than 10 parameters
np = length(instances);
if np < 2
    error(['at least two parameter instances are required. ' ...
        'try requesting more parameters/parameter instances.'])
end
if np > 10
    error(['multidensity will not include more than 10 parameter ' ...
        'instances in a single figure. try requesting fewer parameters/' ...
        'parameter instances.'])
end

%number of levels for the contour plots
nLevels = 8;

%select colors
% ... [on diagonal] smoothed univariate density
marginalFcolor = 'none';%[1 1 1];%0.9*[1 1 1];
marginalEcolor = [0 0 0];
% ... [off diagonal] colormap for contour layer (lowest to hightest density)
% cmap = makecolormap('white','black',128);
cmap = makecolormap(0.925*[1 1 1],'black');
% ... [off diagonal] marker color for divergent transitions
divergentColor = getcolors('red');

% % % %test discrete
% % % instances{1} = 'discrete';  isInstance(1) = 0;
% % % samples.discrete = binornd(10,0.2, ...
% % %     size(samples.(str2ind(instances{end})),[1 2]));

%% make NxN multidensity plot
%start a figure ...
dumf = figure(999); %dummy figure to protect sizing
fh = figure('color',[1 1 1]);
fpos = fh.Position;
fh.Position = [fpos(1:2) [125+125*np 75+125*np]*figScaling];
close(dumf.Number) %close dummy figure
%... and NxN axes
tiledlayout(np,np,'tilespacing','none')%,'tileindexing')%,'columnmajor')

contourForSpeed = true; %be VERY cautious in changing this

%on diagonal: univariate marginal posterior density
for n = 1:(np*np)
    %select an axis
    nexttile; hold on
    %format this axis
    set(gca,'box','on','fontsize',fontSz)
    %determine this axis' position within the grid of axes
    [row,col] = ind2sub([np np],n);
    onDiagonal = row==col;    offDiagonal = ~onDiagonal;
    
    %move X/Y axis to the top/right for the topmost/righmost column of plots
    if row==1, set(gca,'XAxisLocation','top'); end
    if col==np, set(gca,'YAxisLocation','right'); end
    
    %if first row, add parameter name labels
    %iff last row, include rotated tick labels
    if row==1
        title(instances{col},'interpreter','none','fontweight','bold')
    end
    if row < np
        set(gca,'xticklabels',{})
    else
        set(gca,'XTickLabelRotation',90)
    end
    
    %if first column, add parameter name labels
    %iff last column, include tick labels
    %*UNLESS* it is also the last row --- then flip!
%     if col==1
    if (col==1 && row<np) || (col==np && row==np)
        ylabel(instances{row},'interpreter','none','fontweight','bold')
    end
    if ~((col==np && row<np) || (col==1 && row==np))
        set(gca,'yticklabels',{})
    end
    
    %extract samples, while accounting for parameters vs. parameter instances
    %... col determines the X axis
    if isInstance(col)
        [parameter,ind] = str2ind(instances{col});
        chains_xc = samples.(parameter)(:,:,ind{:});
    else
        parameter = instances{col};
        chains_xc = samples.(parameter);
    end
    chains_xc = chains_xc(:);
    xl = [min(chains_xc) max(chains_xc)];
    %... row determines the Y axis
    if offDiagonal
        if isInstance(row)
            [parameter,ind] = str2ind(instances{row});
            chains_yr = samples.(parameter)(:,:,ind{:});
        else
            parameter = instances{row};
            chains_yr = samples.(parameter);
        end
        chains_yr = chains_yr(:);
        yl = [min(chains_yr) max(chains_yr)];
    end
    
    %if on diagonal, univariate marginal posterior density ...
    if onDiagonal
        %smoothed density
        isDiscrete = all(~mod(chains_xc,1));
        [f,x] = smoothdensity(chains_xc);
        if isDiscrete
            %discrete plot
            bar(x,f,'linewidth',linePt, ...
                'facecolor',marginalFcolor,'edgecolor',marginalEcolor)
        else
            %continuous plot
            area(x,f,'linewidth',linePt, ...
                'facecolor',marginalFcolor,'edgecolor',marginalEcolor)
        end
        xlim(xl)
        set(gca,'ytick',[])
    end
    
    %set colormap for contour plots
    colormap(cmap)
    
    %if off diagonal, bivariate marginal posterior density ...
    if offDiagonal
        %contour plot
        if contourForSpeed
            %bivariate histogram
            [Fgrid,Xedges,Yedges] = histcounts2(chains_xc,chains_yr, ...
                'normalization','pdf'); %(actually scaling is optional)
            Fgrid = Fgrid';
            %midpoints of bins
            Xmids = (Xedges(1:end-1) + Xedges(2:end))/2;
            Ymids = (Yedges(1:end-1) + Yedges(2:end))/2; 
            %... meshgrid
            [Xgrid,Ygrid] = meshgrid(Xmids,Ymids);
            maxF = max(Fgrid(:));
            %contour plot where the outermost line/fill includes ALL samples
            %VERSION 1: outline
            % levels = [-1 linspace(eps,maxF+eps,nLevels)];
            levels = linspace(eps,maxF,nLevels); %eps => exclude Fgrid bins with 0 samples
%             contour(Xgrid,Ygrid,Fgrid,'levellist',levels,'linecolor','k')
            contourf(Xgrid,Ygrid,Fgrid, ...
                'levellist',levels,'fill','on')%,'linecolor','flat')
        else
            %scatter plot
            %(MUCH SLOWER AND HUUUUGE MEMORY DRAIN!!!)
            scatter(chains_xc,chains_yr, ...
                    'sizedata',markSz, ...
                    'markerfacecolor',markerFcolor, ...
                    'markeredgecolor',markerEcolor, ...
                    'markerfacealpha',0.5,'markeredgealpha',0.5)
        end
        %overlay divergent transitions
        if overlayDivergent
            plot(chains_xc(divergent==1),chains_yr(divergent==1), ...
                'linestyle','none','linewidth',linePt, ...
                'marker','x','markersize',round(markSz/2), ...
                'markerfacecolor',divergentColor,'markeredgecolor',divergentColor)
        end
        xlim(xl)
        ylim(yl)
    end
    
    %add a colorbar (one plot only!)
    if row==1 && col==np
        %add a colorbar
        cb = colorbar;
        cb.Ticks = [];
        % sz = 1/(np+1);
        % cb.Position = [sz*(np+0.5)+cb.Position(3)*1.5   sz/2  ...
        %                cb.Position(3)*1.5               cb.Position(4)];
    end
end

end
