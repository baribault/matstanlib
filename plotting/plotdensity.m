function plotdensity(varargin)
%PLOTDENSITY plots a smoothed marginal posterior density.
% 
% this function generates a single figure displaying a smoothed univariate 
% marginal density for a given parameter.  
% 
% there are two distinct ways to call this function:
% 
% PLOTDENSITY(SAMPLES,PARAMETER,...)
%   in this syntax, SAMPLES is a structure containing mcmc samples 
%   (consistent with the format generated by extractsamples.m) that has a 
%   field corresponding to the string PARAMETER. 
%   PARAMETER may be the name of a scalar parameter, or an indexed name of 
%   a parameter instance (e.g., 'mu[3]', 'sigma[2,1]').
%   SAMPLES and PARAMETER are both requrired inputs.
% 
% PLOTDENSITY(CHAINS,...)
%   in this syntax, CHAINS is a matrix of samples of size 
%   [nIterations nChains].  this is the only required input.  
% 
% in either syntax, the following optional inputs may be supplied 
% (in any order) to trigger various overlays:
%     'mean'        >>> a vertical line at the mean of the mcmc samples
%     'median'      >>> a vertical line at the median of the mcmc samples
%     'credible',
%     'credible95'  >>> shading beneath the density, between the bounds of 
%                           a (central) 95% credible interval
%     'credible90'  >>> same as above, but for a 90% credible interval
%     'credible50'  >>> same as above, but for a 50% credible interval
%     'hdi'         >>> if submitted with any of the above options, then
%                           the intervals will be *highest-density*
%                           intervals (HDIs) rather than central
%                           intervals/equal-tail intervals (the default)
%     'mode'        >>> a vertical line at the mode of the mcmc samples
%     'argmax'      >>> a vertical line at the maximum of the smoothed 
%                           posterior
%     #             >>> a single, scalar numeric value, represeting the
%                           true value of the parameter (assuming data was 
%                           simulated)
%     'legend'      >>> a legend for all optional overlays
% 
% Examples:
%   PLOTDENSITY(samples,'beta[1]',trueValue.beta(1),'mean','credible','hdi')
%   PLOTDENSITY(samples.beta(:,:,1),'credible95','credible50','legend')
% 
% See also SMOOTHDENSITY, JOINTDENSITY, MULTIDENSITY, VIOLINDENSITY, 
%   EXTRACTSAMPLES
% 
% (c) beth baribault 2019 ---                                 > matstanlib 

matstanlib_options

%% parse required inputs
if nargin == 0
    error('at least one input is required.')
end
if isstruct(varargin{1})
    numRequiredInputs = 2;
    if nargin < numRequiredInputs
        error('too few required inputs for this syntax.')
    end
    if ~ischar(varargin{2})
        error('at least one required input is an invalid type.')
    end
    %first syntax option ...
    %   SAMPLES     = a structure of mcmc samples
    %   PARAMETER   = a parameter name string, which must be a valid 
    %                 scalar parameter name or parameter instance name
    [parameter,ind] = str2ind(varargin{2});
    if isempty(ind)
        %parameter name given
        if ismatrix(varargin{1}.(parameter))
            %scalar parameter
            chains = varargin{1}.(parameter)(:);
        else
            %not actually scalar parameter
            error(['please modify the parameter name input (%s) ' ...
                'to specify which parameter instance (e.g., %s[3])' ...
                'is to be smoothed.'],parameter,parameter)
        end
    else
        %instance name given
        instance = varargin{2};
        nParamDims = ndims(varargin{1}.(parameter)) - 2;
        if length(ind) ~= nParamDims
            error(['the number of indices (%i) in the given ' ...
                'parameter instance name %s does not match the ' ...
                'actual number of parameter dimensions (%i).'], ...
                length(ind),varargin{2},nParamDims)
        end
        chains = varargin{1}.(parameter)(:,:,ind{:});
        chains = chains(:);
        parameter = instance;
    end
elseif isnumeric(varargin{1})
    numRequiredInputs = 1;
    %second syntax option ...
    %   CHAINS     = a matrix of mcmc samples of size [nIterations nChains]
    if ismatrix(varargin{1})
        chains = varargin{1}(:);
    else
        error('chains input must be of size [nIterations nChains].')
    end
else
    error(['invalid number of required inputs or input type(s). ' ...
        'type ''help plotdensity'' for info.'])
end

%% parse optional inputs
validOptions = {'mean','median','mode','argmax','max', ...
                'credible','credible95','credible90','credible50', ...
                'hdi','legend'};
if nargin == numRequiredInputs
    options = {};
elseif nargin > numRequiredInputs
    options = varargin(numRequiredInputs+1:end);
    %check if all are char-array type (or a valid trueValue option)
    isNotString = ~cellfun(@ischar,options);
    if any(isNotString)
        if sum(isNotString) == 1 && isscalar(options{isNotString}) ...
                                 && isnumeric(options{isNotString})
            trueValue = options{isNotString};
            options(isNotString) = [];
        else
            warning('the optional inputs printed below are likely invalid:')
            disp(options(isNotString))
            error('invalid optional input type(s) detected.')
        end
    end
    %if all char-array type, check if all are pre-defined options
    options = lower(options); %case insensitive
    isInvalidOption = ~ismember(options,validOptions);
    if any(isInvalidOption)
        error('invalid optional input string(s) detected: ''%s''', ...
            strjoin(options(isInvalidOption)))
    end
    if isequal({'legend'},options) 
        error('''legend'' cannot be the only optional input.')
    end
end
if any(ismember({'hdi','HDI'},options)) && ...
        ~any(ismember({'credible','credible95','credible90','credible50'},options))
    options{end+1} = 'credible';
end

%% plot smoothed density & overlays
% chains = binornd(10,0.3,size(chains)); %test discrete

%start a figure ...
dumf = figure(999); %dummy figure to protect sizing
f = figure('color',[1 1 1]);
fpos = f.Position;
if ismember('legend',options)
    f.Position = [fpos(1:2) [520 370+12*length(options)]*figScaling];
else
    f.Position = [fpos(1:2) [520 350                   ]*figScaling];
end
close(dumf.Number); %close dummy figure
%... and an axis
ax = gca;
hold on

%start a list of handles & labels for optional overlays/underlays
h = [];
labels = {};

%determine if parameter is discrete or continuous
isDiscrete = all(~mod(chains,1));

%get smoothed marginal density
[f,x] = smoothdensity(chains);

%plot optional underlays
getbounds = @(p) [(1-p)/2   1-(1-p)/2];
if any(ismember({'credible','credible95'},options))
    if any(ismember({'hdi','HDI'},options))
        hdi = computecredint(chains,0.95,'hdi');
        [h,labels] = shadeinterval('95% highest density interval',hdi, ...
            x,f,0.9*[1 1 1],h,labels);
    else
        bounds = getbounds(0.95);
        [h,labels] = shadeinterval('95% credible interval', ...
            [quantile(chains,bounds(1)) quantile(chains,bounds(2))], ...
            x,f,0.9*[1 1 1],h,labels);
    end
end
if ismember('credible90',options)
    if any(ismember({'hdi','HDI'},options))
        hdi = computecredint(chains,0.90,'hdi');
        [h,labels] = shadeinterval('90% highest density interval',hdi, ...
            x,f,0.775*[1 1 1],h,labels);
    else
        bounds = getbounds(0.90);
        [h,labels] = shadeinterval('90% credible interval', ...
            [quantile(chains,bounds(1)) quantile(chains,bounds(2))], ...
            x,f,0.775*[1 1 1],h,labels);
    end
end
if ismember('credible50',options)
    if any(ismember({'hdi','HDI'},options))
        hdi = computecredint(chains,0.50,'hdi');
        [h,labels] = shadeinterval('50% highest density interval',hdi, ...
            x,f,0.575*[1 1 1],h,labels);
    else
        bounds = getbounds(0.50);
        [h,labels] = shadeinterval('50% credible interval', ...
            [quantile(chains,bounds(1)) quantile(chains,bounds(2))], ...
            x,f,0.575*[1 1 1],h,labels);
    end
end

%plot density
if isDiscrete
    bar(x,f,'linewidth',linePt*1.5,'barwidth',0.7, ...
        'facecolor','none','edgecolor',[0 0 0])
    ax.XLim = [min(x)-0.75 max(x)+0.75];
    ax.XTick = min(x):max(x);
else %isContinuous
    plot(x,f,'linewidth',linePt*1.5,'color',[0 0 0])
    ax.XLim = [min(x) max(x)];
end
if exist('parameter','var')
    xlabel(parameter,'interpreter','none','fontweight','bold')
end
ylabel('marginal posterior density')
set(ax,'box','on','fontsize',fontSz)

%plot optional overlays
ylim = ax.YLim;
if any(ismember({'max','argmax'},options))
    [h,labels] = verticalline('max',x(f==max(f)),ylim,linePt, ...
        getcolors('darkgreen'),h,labels);
end
if ismember('mode',options)
    [h,labels] = verticalline('mode',mode(chains),ylim,linePt, ...
        getcolors('lightblue'),h,labels);
end
if ismember('median',options)
    [h,labels] = verticalline('median',median(chains),ylim,linePt, ...
        getcolors('blue'),h,labels);
end
if ismember('mean',options)
    [h,labels] = verticalline('mean',mean(chains),ylim,linePt, ...
        getcolors('darkblue'),h,labels);
end
if exist('trueValue','var')
    [h,labels] = verticalline('true value',trueValue,ylim,linePt, ...
        getcolors('black'),h,labels,'--');
end

%add a legend
if ismember('legend',options) && ~isempty(h) 
    legend(h,labels,'location','southoutside')
end

%reset Y-axis limits
ax.YLim = ylim;

end

%------------------------------------------------------------------------%
function [h,labels] = verticalline(name,xvalue,yvalues,linePt,color,h,labels,dash)
%overlays a vertical line
    if nargin < 8
        dash = '-'; %default is solid line
    end
    h(end+1) = plot(xvalue*[1 1],yvalues,'linewidth',linePt*2,'color',color, ...
        'linestyle',dash);
    labels{end+1} = name;
end

%------------------------------------------------------------------------%
function [h,labels] = shadeinterval(intervalName,bounds,xvals,yvals, ...
    color,h,labels)
%overlays shading under a curve
    inInterval = bounds(1) <= xvals & xvals <= bounds(2);
    xvals = xvals(inInterval);
    yvals = yvals(inInterval);
    h(end+1) = area(xvals,yvals,'facecolor',color,'edgecolor',color);
    labels{end+1} = intervalName;
end