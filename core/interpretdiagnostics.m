function varargout = interpretdiagnostics(diagnostics,posteriorTable, ...
                                          method,printReport,printWarnings)
%INTERPRETDIAGNOSTICS prints a diagnostic report for MCMC output.
%   
% this function prints an automated assessment of HMC/NUTS sampler output
% to the command-line.  a warning is thrown if the model output fails any
% of the currently recommended set of convergence and diagnostic checks. 
% 
% *** please be mindful that assessing the quality of MCMC output is a
% *** nuanced process that goes beyond these simple automated checks!  in
% *** particular, visual inspection of your chains, the marginal densities,
% *** and more are required.  you will likely also need to run parameter
% *** recovery studies, inspect prior & posterior predictives, etc., ... 
% *** (so this is just a handy way to flag failed diagnostic checks ASAP.) 
% 
% 
% 
% INTERPRETDIAGNOSTICS(DIAGNOSTICS,POSTERIORTABLE)
%   generates a command-line report based on DIAGNOSTICS, a structure 
%   of diagnostic quantities (as generated by extractsamples.m), and
%   POSTERIORTABLE, a table of (previously computed) posterior sample-based
%   diagnostics and summary statistics (as generated by mcmctable.m). 
%   
%   by default, the diagnostics are judged according to current best
%   statistical practices (as per Vehtari et al., 2020, etc.).  as such, a
%   warning will be thrown if any of the following conditions are not met: 
%       -- no Rhat > 1.01
%       -- no effective sample sizes < 100 per chain 
%               (i.e., 50 x the number of split chains)
%       -- no divergent transitions
%       -- no BFMI < 0.2
% 
% 
% INTERPRETDIAGNOSTICS(...,METHOD,PRINTREPORT,PRINTWARNINGS)
%   for backwards compatability, previously used methods of interpreting
%   convergence diagnostics are also available.  
%   to use a specific interpretation METHOD, give one of the following
%   strings as an additional input: 
%       'current', 'vehtari'    >>  maximum Rhat of 1.01, 
%                                   minimum ESS of 100 per chain, 
%                                   no divergent transitions, no BFMI < 0.2
%       'BDA3'                  >>  maximum Rhat of 1.1, 
%                                   minimum ESS of 10 per chain, 
%                                   no divergent transitions
%       'BDA2'                  >>  maximum Rhat of 1.1
%   the default value for METHOD is 'current'.
%   
%   if PRINTREPORT is false, then no command line report will be generated.
%   if PRINTWARNINGS is false, then no warnings will be generated.
%   (the default value for both of these optional inputs is true.) 
% 
% 
% NOTE: a non-zero number of divergent transitions being permissible is
%   NOT AN OPTION as, at an absolute minimum, any divergences should always 
%   be actively investigated and scrutinized.
% 
% 
% PASSEDALLCHECKS = INTERPRETDIAGNOSTICS(...)
%   PASSEDALLCHECKS is an optional output.
%   PASSEDALLCHECKS is true if the minimum requirements were satisfied, 
%   and false otherwise.  
% 
% 
% Reference for 'current' interpretation method:
%             Vehtari, Gelman, Simpson, Carpenter, BÃ¼rkner (2020, May). 
%                   Rank-normalization, folding, and localization: An
%                   improved R^ for assessing convergence of MCMC.  ArXiv.
% Reference for 'BDA3' interpretation method:
%             Gelman, Carlin, Stern, Dunson, Vehtari, & Rubin (2013).
%                 Bayesian Data Analysis, 3rd ed. CRC.
% Reference for 'BDA2' interpretation method:
%             Gelman, Carlin, Stern, & Rubin (2003). Bayesian Data
%                 Analysis, 2nd edition. Chapman & Hall.
% 
% 
% See also EXTRACTSAMPLES, MCMCTABLE
% 
% (c) beth baribault 2019 ---                                 > matstanlib 


%% parse inputs
%diagnostics
if ~isstruct(diagnostics)
    error(['first input must be the diagnostics structure ' ...
        '(in the format generated by extractsamples.m).'])
end
%check the variables needed are there
requiredFields = {'accept_stat__','stepsize__','treedepth__','divergent__'};
missingFields = setdiff(requiredFields,fieldnames(diagnostics));
if ~isempty(missingFields)
    if length(missingFields)>1, pluralStr = 's'; else, pluralStr = ''; end
    error(['diagnostics is missing the required field%s ''%s''.  ' ...
        '(did you submit the right structure?)'], ...
        pluralStr,strjoin(missingFields,''' and '''),method)
end

%posteriorTable
if ~istable(posteriorTable)
    error(['second input must the posteriorTable table ' ...
        '(as in the format generated by mcmctable.m).'])
elseif ~ismember('rhat',posteriorTable.Properties.VariableNames)
    error(['posteriorTable is missing the required variable ''rhat''.  ' ...
        '(did you submit the right table?)'])
end

%%% optional inputs %%%
%method
validMethods = {'current','vehtari','BDA3','BDA2'};
if nargin < 3 || isempty(method)
    method = 'current'; %default is current best practice
elseif ischar(method)
    if ~ismember(method,validMethods)
        error(['''%s'' is not a valid evaluation method.  \n' ...
            'valid evaluation methods include: ''%s'''], ...
            method,strjoin(validMethods,''', '''))
    end
else
    error('the evaluation method must be a string (@ischar==true).')
end

%printReport & printWarnings
if nargin < 5 || isempty(printReport)
    printReport = true;
else
    if ~ismember(printReport,[0 1])
        error('printReport must be convertible to logical value.')
    end
end
if nargin < 6 || isempty(printWarnings)
    printWarnings = true;
else
    if ~ismember(printWarnings,[0 1])
        error('printWarnings must be convertible to logical value.')
    end
end

%% set a standard by which to evaluate the diagnostics
%set standards
nChains = size(diagnostics.accept_stat__,2);
switch method
    case {'current','vehtari'}
        maxRhat = 1.01;
        minESS = 100*nChains;   % = 50 per number of split chains
        checkDivergence = true;
        minBFMI = 0.2;
        requiredVariables = {'rhat','ess_bulk','ess_tail'};
    case 'BDA3'
        maxRhat = 1.1;
        minESS = 10*nChains;    % = 5 per number of split chains
        checkDivergence = true;
        minBFMI = NaN;
        requiredVariables = {'rhat','n_eff'};
    case 'BDA2'
        maxRhat = 1.1;
        minESS = NaN;           % ... no minimum ???
        checkDivergence = false;
        minBFMI = NaN;
        requiredVariables = {'rhat'};
end

%check the variables needed are there
missingVariables = setdiff(requiredVariables,posteriorTable.Properties.VariableNames);
if ~isempty(missingVariables)
    if length(missingVariables)>1, pluralStr = 's'; else, pluralStr = ''; end
    error(['posteriorTable is missing the variable%s ''%s'' ' ...
        'required for interpretation method ''%s''.  ' ...
        '(you may need to re-generate posteriorTable!)'], ...
        pluralStr,strjoin(missingVariables,''' and '''),method)
end

%% interpret diagnostics from Stan
vprintf(printReport,'\ninterpreting mcmc diagnostics ... \n')

%(don't print a table that's too long!)
maxNreport = 25;


%extract dimensions
nInstances = size(posteriorTable,1);

%assess stan diagnostics
vprintf(printReport,'    the acceptance rate was:            %.3f\n', ...
    mean(diagnostics.accept_stat__(:)))
vprintf(printReport,'    the average step size was:          %.3f\n', ...
    mean(diagnostics.stepsize__(:)))
vprintf(printReport,'    the average tree depth was:         %.3f\n\n', ...
    mean(diagnostics.treedepth__(:)))

%% assess Bayesian fraction of missing information

%get BFMI for each chain 
BFMI = computebfmi(diagnostics.energy__);

%check BFMI ... 
if ~isnan(minBFMI) && any(BFMI < minBFMI)
    passedBFMICheck = false;
else
    passedBFMICheck = true;
end
% ... and report
if ~passedBFMICheck
    vwarning(printWarnings, ...
        ['%i out of %i chains had a Bayesian fraction of missing information ' ...
        'that was too low (< %g)! ' ...
        'please use diagnostic plots to investigate potential remedies. ' ...
        'do not use these samples as the basis for inference.'], ...
        sum(BFMI < minBFMI),length(BFMI),minBFMI)
    vdisp(printReport,' ')
else
    vprintf(printReport,'    no BFMI under %g :)\n',minBFMI)
end

%% assess divergent transitions
%check for divergences... 
if checkDivergence && any(diagnostics.divergent__(:)==1)
    passedDivergenceCheck = false;
else
    passedDivergenceCheck = true;
end
% ... and report
if ~passedDivergenceCheck
    nDivergent = sum(diagnostics.divergent__(:));
    percentDivergent = 100*nDivergent/numel(diagnostics.divergent__);
    if percentDivergent < 3/4000 && nDivergent < 3
        warnStr = ['it is not advisable to use these samples as ' ...
            'the basis for inference.'];
    elseif percentDivergent < 0.1
        warnStr = 'do not use these samples as the basis for inference.';
    else
        warnStr = 'DO NOT USE THESE SAMPLES AS THE BASIS FOR INFERENCE.';
    end
    vwarning(printWarnings, ...
        ['there were %i divergent transitions (%.2f%% of samples)! ' ...
        'please use diagnostic plots to investigate potential remedies. ' ...
        '%s'],sum(diagnostics.divergent__(:)),percentDivergent,warnStr)
    vdisp(printReport,' ')
else
    vprintf(printReport,'    no divergent transitions :)\n')
end

%% interpret convergence diagnostics
%check Rhat ... 
isBadRhat = posteriorTable.rhat > maxRhat;
if any(isBadRhat), passedRhatCheck = false; else, passedRhatCheck = true; end
% ... and report
if ~passedRhatCheck
    vwarning(printWarnings, ...
        '%i out of %i parameters have bad Rhat values (> %g):', ...
        sum(isBadRhat),nInstances,maxRhat)
    if sum(isBadRhat) > maxNreport
        vprintf(printReport,['\n    printing the first %i parameter instances ' ...
            'with high Rhat ...\n'],maxNreport)
        indBadRhat = find(isBadRhat);
        vdisp(printReport,posteriorTable(indBadRhat(1:25),:))
    else
        vdisp(printReport,posteriorTable(isBadRhat,:))
    end
else
    vprintf(printReport,'    no Rhat statistics over %g :)\n',maxRhat)
end

%check ESS estimates ...
switch method
    case {'current','vehtari'}
        isBadESS = posteriorTable.ess_bulk<minESS | posteriorTable.ess_tail<minESS;
    case {'BDA3','BDA2'}
        isBadESS = posteriorTable.n_eff < minESS;
end
if any(isBadESS), passedESSCheck = false; else, passedESSCheck = true; end
% ... and report
if ~passedESSCheck
    minESS_perChain = minESS/nChains;
    vwarning(printWarnings, ...
        ['the effective sample size for %i out of %i parameters ' ...
        'is too low (< %i [= %i*number of chains]):'], ...
        sum(isBadESS),nInstances,minESS,minESS_perChain)
    if sum(isBadESS) > maxNreport
        vprintf(printReport,['\n    printing the first %i parameter instances ' ...
            'with low ESS ...\n'],maxNreport)
        indBadESS = find(isBadESS);
        vdisp(printReport,posteriorTable(indBadESS(1:maxNreport),:))
    else
        vdisp(printReport,posteriorTable(isBadESS,:))
    end
else
    vprintf(printReport, ...
        '    no effective sample sizes under %i :)\n',minESS)
end

vprintf(printReport,'\n')

%% determine if evaluation criteria were satisfied
passedAllChecks = ...
    passedRhatCheck && passedESSCheck && passedDivergenceCheck && passedBFMICheck;
if nargout == 1
    varargout{1} = passedAllChecks;
end

end

%% -------------------------------------------------------------------- %%
function vprintf(printReport,str,varargin)
    if nargin == 2 && printReport
        fprintf(str)
    elseif nargin > 2 && printReport
        fprintf(str,varargin{:})
    else
        %do not print!
    end
end

%% -------------------------------------------------------------------- %%
function vdisp(printReport,variable)
    if printReport
        disp(variable)
    else
        %do not print!
    end
end

%% -------------------------------------------------------------------- %%
function vwarning(printWarnings,str,varargin)
    if nargin == 2 && printWarnings
        warning(str)
    elseif nargin > 2 && printWarnings
        warning(str,varargin{:})
    else
        %do not print!
    end
end